Import /Eq;

Axiom is_Field: U -> U;

Axiom add_comm: ∀ F: U, is_Field F -> ∀ x y: F, x + y = y + x;
Suggest goal default apply add_comm with label Trivial;
Axiom add_assoc: ∀ F: U, is_Field F -> ∀ x y z: F, x + y + z = x + (y + z);
Suggest goal default apply add_assoc with label Trivial;
Axiom #1 f0: ∀ F: U, F -> F;
Axiom f0_prop: ∀ F: U, is_Field F -> ∀ x y: F, f0 y + x = x;
Axiom neg_prop: ∀ F: U, is_Field F -> ∀ x y: F, x + (-x) = f0 y;

Axiom mul_comm: ∀ F: U, is_Field F ->  ∀ x y: F, x * y = y * x;
Suggest goal default apply mul_comm with label Trivial;
Axiom mul_assoc: ∀ F: U, is_Field F ->  ∀ x y z: F, x * y * z = x * (y * z);
Suggest goal default apply mul_assoc with label Trivial;
Axiom #1 f1: ∀ F: U, F -> F;
Axiom f1_ineq_f0: ∀ F: U, is_Field F -> ∀ x y: F, ~ f1 x = f0 y;
Axiom f1_prop: ∀ F: U, is_Field F -> ∀ x y: F, f1 y * x = x;
Axiom #1 fdiv: ∀ F: U, F -> F;
Axiom fdiv_prop: ∀ F: U, is_Field F -> ∀ x y z: F, ~ x = f0 z -> x * (fdiv x) = f1 y; 

Axiom dstb_law_l: ∀ F: U, is_Field F -> ∀ x y z: F, x * (y + z) = x * y + x * z;
Suggest goal default apply dstb_law_l with label Trivial;
Todo dstb_law_r: ∀ F: U, is_Field F -> ∀ x y z: F, (y + z) * x = y * x + z * x;
Suggest goal default apply dstb_law_r with label Trivial;
Axiom minus_neg: ∀ F: U, is_Field F -> ∀ x y: F, x - y = x + (-y);

Theorem zero_unique: ∀ F: U, is_Field F -> ∀ x y: F, f0 x = f0 y;
Proof;
    intros;
    replace #1 (f0 y) with (f0 y + f0 x);
    apply eq_sym ;
    replace #1 (f0 y + f0 x) with (f0 x + f0 y);
    apply add_comm;
    assumption;
    apply f0_prop;
    assumption;
    apply eq_sym ;
    apply f0_prop;
    assumption;
Qed;
Theorem one_unique: ∀ F: U, is_Field F -> ∀ x y: F, f1 x = f1 y;
Proof;
    intros;
    replace #1 (f1 y) with (f1 y * f1 x);
    apply eq_sym ;
    replace #1 (f1 y * f1 x) with (f1 x * f1 y);
    apply mul_comm;
    assumption;
    apply f1_prop;
    assumption;
    apply eq_sym ;
    apply f1_prop;
    assumption;
Qed;
Theorem add_cancle_l: ∀ F: U, is_Field F -> ∀ x y z: F, x + y = x + z -> y = z;
Proof;
    intros;
    add_hyp (x + y + (-x) = x + z + (-x));
    rewrite H0 ;
    auto_list;
    add_hyp (∀ x0 y0 z0: F, x0 + y0 + z0 = x0 + z0 + y0);
    intros;
    replace #1 (x0 + y0 + z0) with (x0 + (y0 + z0));
    apply add_assoc;
    assumption;
    replace #1 ((y0 + z0)) with ((z0 + y0));
    apply add_comm;
    assumption;
    apply eq_sym ;
    apply add_assoc;
    assumption;
    replace #1 (x + y + - x) with (x + - x + y) in H1;
    apply H2;
    replace #1 (x + z + - x) with (x + - x +z) in H1;
    apply H2;
    replace #1 (x + - x) with (f0 x) in H1;
    apply neg_prop;
    assumption;
    replace #1 (f0 x + y) with ( y) in H1;
    apply f0_prop;
    assumption;
    replace #1 (x + - x) with (f0 x) in H1;
    apply neg_prop;
    assumption;
    replace #1 (f0 x + z) with ( z) in H1;
    apply f0_prop;
    assumption;
    assumption;
Qed;
Theorem add_cancle_r: ∀ F: U, is_Field F -> ∀ x y z: F, y + x = z + x -> y = z;
Proof;
    intros;
    replace #1 (y + x) with (x + y) in H0;
    apply add_comm;
    assumption;
    replace #1 (z + x) with ( x + z) in H0;
    apply add_comm;
    assumption;
    apply (⁨add_cancle_l ?0 ?2 x ?6 ?8 ?10⁩);
    assumption;
    assumption;
Qed;
Theorem neg_unique: ∀ F: U, is_Field F -> ∀ x y z: F, x + y = f0 z -> y = - x;
Proof;
    intros;
    replace #1 (f0 z) with (x + (-x)) in H0;
    apply eq_sym ;
    apply neg_prop;
    assumption;
    apply add_cancle_l in H0;
    assumption;
    assumption;
Qed;
Theorem double_neg: ∀ F: U, is_Field F -> ∀ x: F, - - x = x;
Proof;
    intros;
    apply (⁨add_cancle_r ?0 ?2 (- x) ?6 ?8 ?10⁩);
    replace #1 (- - x + - x) with (f0 (x));
    replace #1 (- - x + - x) with ( - x + - - x);
    apply add_comm;
    assumption;
    apply neg_prop;
    assumption;
    apply eq_sym ;
    apply neg_prop;
    assumption;
    assumption;
Qed;

Theorem zero_mul: ∀ F: U, is_Field F -> ∀ x y: F, f0 y * x = f0 y;
Proof;
    intros;
    apply (⁨add_cancle_l ?0 ?2 (f0 y * x) ?6 ?8 ?10⁩);
    replace #1 (f0 y * x + f0 y * x) with ((f0 y  + f0 y) * x);
    apply eq_sym;
    apply dstb_law_r;
    assumption;
    replace #1 ((f0 y + f0 y)) with ((f0 y));
    apply f0_prop;
    assumption;
    apply eq_sym ;
    replace #1 (f0 y * x + f0 y) with (f0 y + f0 y * x );
    apply add_comm;
    assumption;
    apply f0_prop;
    assumption;
    assumption;
Qed;
Theorem mul_ineq_zero: ∀ F: U, is_Field F -> ∀ x y z t a: F, ~ x = f0 z -> ~ y = f0 t -> ~ x * y = f0 a;
Proof;
    intros;
    add_hyp (x * y * (fdiv x * fdiv y) = f0 a  * (fdiv x * fdiv y));
    rewrite H2;
    auto_list;
    replace #1 (f0 a * (fdiv x * fdiv y)) with (f0 a ) in H3;
    apply zero_mul;
    assumption;
    replace #1 (x * y * (fdiv x * fdiv y)) with (x * (y * (fdiv x * fdiv y))) in H3;
    apply mul_assoc;
    assumption;
    replace #1 ((fdiv x * fdiv y)) with ((fdiv y * fdiv x)) in H3;
    apply mul_comm;
    assumption;
    replace #1 ((y * (fdiv y * fdiv x))) with ((y * fdiv y * fdiv x)) in H3;
    apply eq_sym;
    apply mul_assoc;
    assumption;
    replace #1 (y * fdiv y) with (f1 y) in H3;
    apply (⁨fdiv_prop ?0 ?2 ?4 ?6 t ?10⁩);
    assumption;
    assumption;
    replace #1 ((f1 y * fdiv x)) with (( fdiv x)) in H3;
    apply f1_prop;
    assumption;
    replace #1 (x * fdiv x) with (f1 x) in H3;
    apply (⁨fdiv_prop ?0 ?2 ?4 ?6 z ?10⁩);
    assumption;
    assumption;
    apply f1_ineq_f0 in H3;
    assumption;
    assumption;
Qed;
Theorem minus_mul_l: ∀ F: U, is_Field F -> ∀ x y: F, (- x) * y = - (x * y);
Proof;
    intros;
    apply (⁨add_cancle_l ?0 ?2 (x * y) ?6 ?8 ?10⁩);
    replace #1 (x * y + - x * y) with ((x  + - x) * y);
    apply eq_sym ;
    apply dstb_law_r;
    assumption;
    replace #1 ((x + - x)) with (f0 x);
    apply neg_prop;
    assumption;
    replace #1 (x * y + - (x * y)) with (f0 x);
    apply neg_prop;
    assumption;
    apply zero_mul;
    assumption;
    assumption;
Qed;
Theorem minus_mul_r: ∀ F: U, is_Field F -> ∀ x y: F, x * (- y) = - (x * y);
Proof;
    intros;
    add_from_lib minus_mul_l;
    add_hyp minus_mul_l_ex := (minus_mul_l (F));
    Seq (add_hyp (⁨is_Field F⁩)) (remove_hyp minus_mul_l_ex) (Switch 1) (add_hyp minus_mul_l_ex_o := (minus_mul_l_ex H0)) (remove_hyp H0) (remove_hyp minus_mul_l_ex) ;
    add_hyp minus_mul_l_ex_o_ex := (minus_mul_l_ex_o (y));
    add_hyp minus_mul_l_ex_o_ex_ex := (minus_mul_l_ex_o_ex (x));
    replace #1 (- y * x) with (x * - y) in minus_mul_l_ex_o_ex_ex;
    apply mul_comm;
    assumption;
    rewrite minus_mul_l_ex_o_ex_ex ;
    replace #1 ((y * x)) with ((x * y));
    apply mul_comm;
    assumption;
    auto_list;
    assumption;
Qed;
