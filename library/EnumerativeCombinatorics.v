Import /Set;
Import /List;
Import /NumberTheory;
Import /Sigma;

Theorem add_len: ∀ T: U, ∀ S: set T, ∀ n: ℤ, n ≥ 0 → |S| = n → ∀ a: T, ~ a ∈ S → |S ∪ {a}| = n + 1;
Proof;
    intros;
    replace #1 (n) with (|S|);
    auto_set;
    apply finite_add_len;
    assumption;
    apply len_ge_0_finite;
    lia;
Qed;

Todo subset_len: ∀ T: U, ∀ S: set T, ∀ n: ℤ, n ≥ 0 → |S| = n + 1 -> ∀ a: T, a ∈ S -> |S ∖ {a}| = n;
Suggest goal default apply subset_len with label |S ∖ {a}| = n => a ∈ S ∧ |S| = n + 1;

Import /Combinatorics;

Theorem asle_jame: ∀ T: U, ∀ A B: set T, ∀ n m: ℤ, n ≥ 0 -> m ≥ 0 -> |A| = n -> |B| = m -> A ∩ B = {} -> |A ∪ B| = n + m;
Proof;
    intros T A B n m Hn;
    revert A;
    revert B;
    revert m;
    revert Hn;
    revert n;
    apply z_induction_simple;
    Switch 1;
    intros;
    apply empty_len_unique in H0;
    replace #1 (A ∪ B) with (B);
    rewrite H0;
    auto_set;
    lia;
    intros;
    add_hyp (∃ x: T, x ∈ A);
    apply len_gt_0_not_empty_set;
    lia;
    destruct H5 with (ex_ind ? ?) to (x x_property);
    replace #1 (A ∪ B) with (((A ∖ {x}) ∪ B) ∪ {x});
    auto_set;
    replace #1 (n + 1 + m) with (n + m + 1);
    lia;
    apply add_len;
    intros;
    apply union_unfold in H5;
    destruct H5 with (or_ind ? ?);
    add_hyp (x ∈ A ∩ B);
    auto_set;
    replace #1 (A ∩ B) with ({}) in H6;
    assumption;
    auto_set;
    auto_set;
    Switch 1;
    lia;
    apply H0;
    apply empty_set_eq;
    intros;
    apply eq_set_empty in H4;
    add_hyp H4_ex := (H4 (x0));
    auto_set;
    assumption;
    replace #1 (A) with ((A ∖ {x}) ∪ {x}) in H2;
    auto_set;
    replace #1 (|A ∖ {x} ∪ {x}|) with (|A ∖ {x}| + |{x}|) in H2;
    replace #1 (|{x}|) with (1);
    apply singleton_len;
    apply add_len;
    auto_set;
    auto_list;
    apply finite_len_ge_0;
    apply (⁨finite_included ?0 ?2 A ?6 ?8⁩);
    auto_set;
    apply len_ge_0_finite;
    replace #1 (A ∖ {x} ∪ {x}) with (A) in H2;
    auto_set;
    lia;
    replace #1 (|{x}|) with (1) in H2;
    apply singleton_len;
    lia;
    assumption;
Qed;
Theorem rule_of_minus2: ∀ T: U, ∀ U A: set T, ∀ n m a: ℤ, n ≥ 0 -> m ≥ 0 -> |U| = n -> |U ∖ A| = m -> A ⊆ U -> a = n - m -> |A| = a;
Proof;
    intros;
    replace #1 (A) with (U0 ∖ (U0 ∖ A));
    auto_set;
    rewrite H4;
    apply eq_sym in H1;
    rewrite H1;
    apply eq_sym in H2;
    rewrite H2;
    apply rule_of_minus;
    auto_set;
    apply len_ge_0_finite;
    lia;
Qed;

Definition #2 injective := λ A B: U, λ f: A -> B, λ S: set A, ∀ x y: A, x ∈ S -> y ∈ S -> f x = f y -> x = y;
Theorem injective_unfold: ∀ A B: U, ∀ f: A -> B, ∀ S: set A, injective f S -> (∀ x y: A, x ∈ S -> y ∈ S -> f x = f y -> x = y);
Proof; unfold injective; intros A B f S H; assumption; Qed;
Theorem injective_fold: ∀ A B: U, ∀ f: A -> B, ∀ S: set A, (∀ x y: A, x ∈ S -> y ∈ S -> f x = f y -> x = y) -> injective f S;
Proof; unfold injective; intros; assumption; Qed;
Suggest hyp default apply injective_unfold in $n with label Destruct;
Suggest goal default apply injective_fold with label Destruct;
Todo injective_included: ∀ A B: U, ∀ f: A -> B, ∀ x y: set A, x ⊆ y -> injective f y -> injective f x;
Todo injective_map: ∀ X Y: U, ∀ f: X -> Y, ∀ S: set (list X), ∀ D: set X, (∀ l, l ∈ S -> member_set l ⊆ D) -> injective f D -> injective (map f) S;

Definition #2 projection := λ A B: U, λ S: set A, λ f: A -> B, { y: B | ∃ x: A, x ∈ S ∧ y = f x };
Axiom projection_in_intro_l: ∀ A B: U, ∀ f: A -> B, ∀ S: set A, ∀ y: B, y ∈ projection S f -> ∃ x: A, x ∈ S ∧ y = f x;
Axiom projection_in_intro_r: ∀ A B: U, ∀ f: A -> B, ∀ S: set A, ∀ y: B, (∃ x: A, x ∈ S ∧ y = f x) -> y ∈ projection S f;
Suggest hyp default apply projection_in_intro_l in $n with label Destruct;
Suggest goal default apply projection_in_intro_r with label Destruct;

Axiom projection_empty: ∀ A B: U, ∀ f: A -> B, projection {} f = {};
Axiom projection_empty_unique:  ∀ A B: U, ∀ f: A -> B, ∀ S: set A, projection S f = {} -> S = {};
Todo projection_singleton: ∀ A B: U, ∀ f: A -> B, ∀ a: A, projection {a} f = {f a};
Todo projection_union: ∀ A B: U, ∀ f: A -> B, ∀ x y: set A, projection (x ∪ y) f = projection x f ∪ projection y f;
Theorem projection_del: ∀ A B: U, ∀ f: A -> B, ∀ S: set A, ∀ b: B, b ∈ projection S f -> projection S f ∖ {b} = projection (S ∖ {a | f a = b}) f;
Proof;
    intros;
    apply set_equality ;
    apply included_fold ;
    intros;
    apply setminus_fold ;
    apply projection_in_intro_l in H0 ;
    destruct H0 with (ex_ind ? ?) to (x x_property);
    destruct x_property with (and_ind ? ?) to (x_property_l x_property_r) ;
    apply setminus_unfold in x_property_l ;
    destruct x_property_l with (and_ind ? ?) to (x_property_l_l x_property_l_r) ;
    apply and_intro ;
    intros;
    Seq (add_hyp (⁨x ∈ { a0: A | f a0 = b }⁩)) (remove_hyp x_property_l_r) (Switch 1) (add_hyp x_property_l_r_o := (x_property_l_r H1)) (remove_hyp H1) (remove_hyp x_property_l_r) ;
    assumption;
    apply set_from_func_fold ;
    auto_set;
    apply projection_in_intro_r ;
    apply (ex_intro ? ? (x));
    assumption;
    apply included_fold ;
    intros;
    apply projection_in_intro_r ;
    apply setminus_unfold in H0 ;
    destruct H0 with (and_ind ? ?) to (H0_l H0_r) ;
    apply projection_in_intro_l in H0_l ;
    destruct H0_l with (ex_ind ? ?) to (x x_property);
    apply (ex_intro ? ? (x));
    apply and_intro ;
    assumption;
    apply setminus_fold ;
    apply and_intro ;
    intros;
    Seq (add_hyp (⁨a ∈ {b}⁩)) (remove_hyp H0_r) (Switch 1) (add_hyp H0_r_o := (H0_r H1)) (remove_hyp H1) (remove_hyp H0_r) ;
    assumption;
    apply set_from_func_unfold in H0 ;
    auto_set;
    assumption;
Qed;

Theorem rule_of_bijectionR: ∀ A B: U, ∀ f: A -> B, ∀ S: set A, injective f S -> ∀ n: ℤ, n ≥ 0 -> |projection S f| = n -> |S| = n;
Proof;
    intros;
    revert H1;
    revert H;
    revert S;
    revert f;
    revert H0;
    revert n;
    apply z_induction_simple;
    Switch 1;
    intros;
    apply empty_len_unique in H1;
    apply projection_empty_unique in H1;
    rewrite H1;
    lia;
    intros;
    add_hyp (∃ y: B, y ∈ projection S f);
    apply len_gt_0_not_empty_set;
    lia;
    destruct H2 with (ex_ind ? ?) to (y y_property);
    apply projection_in_intro_l in y_property;
    destruct y_property with (ex_ind ? ?) to (x x_property);
    replace #1 (S) with ((S ∖ {x}) ∪ {x});
    auto_set;
    apply asle_jame;
    auto_set;
    apply singleton_len;
    apply (⁨H0 f ?2 ?4 ?6⁩);
    replace #1 (projection (S ∖ {x}) f) with (projection (S) f ∖ {y});
    apply set_equality;
    apply included_fold;
    intros;
    apply setminus_unfold in H2;
    destruct H2 with (and_ind ? ?) to (H2_l H2_r);
    apply projection_in_intro_l in H2_l;
    destruct H2_l with (ex_ind ? ?) to (xp xp_property);
    apply projection_in_intro_r;
    apply (ex_intro ? ? (xp));
    apply and_intro;
    assumption;
    apply setminus_fold;
    apply and_intro;
    intros;
    apply singleton_unfold in H2;
    destruct xp_property with (and_ind ? ?) to (xp_property_l xp_property_r);
    add_hyp (a = y);
    Seq (add_hyp (⁨a ∈ {y}⁩)) (remove_hyp H2_r) (Switch 1) (add_hyp H2_r_o := (H2_r H3)) (remove_hyp H3) (remove_hyp H2_r);
    assumption;
    apply singleton_fold;
    destruct x_property with (and_ind ? ?) to (x_property_l x_property_r);
    replace #1 (xp) with (x) in xp_property_r;
    auto_set;
    auto_set;
    auto_set;
    assumption;
    apply included_fold;
    intros;
    apply projection_in_intro_l in H2;
    apply setminus_fold;
    apply and_intro;
    intros;
    apply singleton_unfold in H3;
    destruct H2 with (ex_ind ? ?) to (xp xp_property);
    destruct xp_property with (and_ind ? ?) to (xp_property_l xp_property_r);
    add_hyp (x = xp);
    apply injective_unfold in H1;
    apply H1;
    auto_set;
    auto_set;
    assumption;
    auto_set;
    destruct H2 with (ex_ind ? ?) to (xp xp_property);
    apply projection_in_intro_r;
    apply (ex_intro ? ? (xp));
    auto_set;
    apply subset_len;
    apply projection_in_intro_r;
    apply (ex_intro ? ? (x));
    assumption;
    assumption;
    assumption;
    apply (⁨injective_included ?0 ?2 ?4 ?6 S ?10 ?12⁩);
    assumption;
    auto_set;
    lia;
    assumption;
Qed;

Axiom projection_finiteR: ∀ A B: Universe, ∀ f: A → B, ∀ S: set A, finite S → finite (projection S f);

Theorem rule_of_bijection: ∀ A B: U, ∀ f: A -> B, ∀ S: set A, finite S -> injective f S -> |projection S f| = |S|;
Proof;
intros A B f;
apply set_induction;
Switch 1;
intros;
replace #1 (projection {} f) with ({});
apply projection_empty;
lia;
intros;
replace #1 (projection (x ∪ {a}) f) with (projection (x) f ∪ projection {a} f);
apply projection_union;
replace #1 (|x ∪ {a}|) with (|x| + 1);
apply finite_add_len;
assumption;
assumption;
replace #1 (projection {a} f) with ({f a});
apply projection_singleton;
replace #1 (|projection x f ∪ {f a}|) with (|projection x f| + 1);
apply finite_add_len;
intros;
apply projection_in_intro_l in H3;
destruct H3 with (ex_ind ? ?) to (xp xp_property);
destruct xp_property with (and_ind ? ?) to (xp_property_l xp_property_r);
apply injective_unfold in H2;
apply H2 in xp_property_r;
auto_set;
auto_set;
auto_set;
apply projection_finiteR;
assumption;
Seq (add_hyp (⁨injective f x⁩)) (remove_hyp H0) (Switch 1) (add_hyp H0_o := (H0 H3)) (remove_hyp H3) (remove_hyp H0) ;
lia;
apply (⁨injective_included ?0 ?2 ?4 ?6 (x ∪ {a}) ?10 ?12⁩);
assumption;
auto_set;
Qed;

Import /Arith;
Import /Logic;
Import /Eq;


Theorem asl_zarb2: ∀ X: U, ∀ C: set X, ∀ n m: ℤ, n > 0 -> m > 0 -> ∀ Y: U, ∀ f: X -> Y, |projection C f| = n -> (∀ y: Y, y ∈ (projection C f) -> |{ x: X | x ∈ C ∧ f x = y }| = m) -> ∀ c: ℤ, c = n * m -> |C| = c;
Proof;
    intros;
    rewrite H3;
    remove_hyp H3;
    remove_hyp c;
    revert H1;
    add_hyp (1 ≤ n);
    lia;
    remove_hyp H;
    revert H2;
    revert C;
    revert H1;
    revert n;
    apply z_induction_simple;
    intros;
    add_from_lib len_gt_0_not_empty_set;
    add_hyp len_gt_0_not_empty_set_ex := (len_gt_0_not_empty_set (Y));
    add_hyp len_gt_0_not_empty_set_ex_ex := (len_gt_0_not_empty_set_ex (projection C f));
    Seq (add_hyp (⁨0 < |projection C f|⁩)) (remove_hyp len_gt_0_not_empty_set_ex_ex) (Switch 1) (add_hyp len_gt_0_not_empty_set_ex_ex_o := (len_gt_0_not_empty_set_ex_ex H3)) (remove_hyp H3) (remove_hyp len_gt_0_not_empty_set_ex_ex);
    destruct len_gt_0_not_empty_set_ex_ex_o with (ex_ind ? ?) to (c c_property);
    remove_hyp len_gt_0_not_empty_set_ex;
    replace #1 (C) with ((C ∖ {x | f x = c } ) ∪ {x | f x = c ∧ x ∈ C });
    apply set_equality;
    add_hyp ({ x: X | f x = c ∧ x ∈ C } ⊆ C);
    apply included_fold;
    intros;
    apply set_from_func_unfold in H3;
    assumption;
    auto_set;
    apply included_fold;
    intros;
    apply union_fold;
    chain (apply or_to_imply) (intros);
    apply setminus_fold;
    apply and_intro;
    intros;
    Seq (add_hyp (⁨a ∈ { x: X | f x = c ∧ x ∈ C }⁩)) (remove_hyp H4) (Switch 1) (add_hyp H4_o := (H4 H6)) (remove_hyp H6) (remove_hyp H4);
    assumption;
    apply set_from_func_fold;
    apply set_from_func_unfold in H5;
    assumption;
    assumption;
    replace #1 ((n + 1) * m) with (n * m +  m);
    lia;
    apply asle_jame;
    apply empty_set_eq;
    intros;
    apply intersection_unfold in H3;
    destruct H3 with (and_ind ? ?) to (H3_l H3_r);
    apply set_from_func_unfold in H3_r;
    apply setminus_unfold in H3_l;
    destruct H3_l with (and_ind ? ?) to (H3_l_l H3_l_r);
    Seq (add_hyp (⁨x ∈ { x0: X | f x0 = c }⁩)) (remove_hyp H3_l_r) (Switch 1) (add_hyp H3_l_r_o := (H3_l_r H3)) (remove_hyp H3) (remove_hyp H3_l_r);
    assumption;
    apply set_from_func_fold;
    assumption;
    replace #1 ({ x: X | f x = c ∧ x ∈ C }) with ({ x: X |  x ∈ C ∧ f x = c });
    apply set_from_func_eq;
    intros;
    assumption;
    apply H2;
    assumption;
    apply H1;
    replace #1 (projection (C ∖ { x: X | f x = c }) f) with (projection (C) f ∖ {c});
    apply eq_sym;
    apply projection_del;
    assumption;
    apply subset_len;
    assumption;
    assumption;
    lia;
    intros;
    replace #1 (projection (C ∖ { x: X | f x = c }) f) with (projection (C ) f ∖ {c}) in H3;
    apply eq_sym;
    apply projection_del;
    assumption;
    replace #1 ({ x: X | x ∈ C ∖ { x0: X | f x0 = c } ∧ f x = y }) with ({ x: X | x ∈ C  ∧ f x = y });
    apply set_from_func_eq;
    intros;
    apply and_intro;
    intros;
    apply and_intro;
    assumption;
    apply setminus_fold;
    apply and_intro;
    intros;
    apply set_from_func_unfold in H5;
    auto_set;
    assumption;
    auto_set;
    apply H2;
    auto_set;
    assumption;
    z3;
    lia;
    intros;
    apply len_eq_1_sing in H1 ;
    destruct H1 with (ex_ind ? ?) to (c c_property);
    add_hyp H2_ex := (H2 (c));
    Seq (add_hyp (⁨c ∈ projection C f⁩)) (remove_hyp H2_ex) (Switch 1) (add_hyp H2_ex_o := (H2_ex H)) (remove_hyp H) (remove_hyp H2_ex) ;
    replace #1 ({ x: X | x ∈ C ∧ f x = c }) with (C) in H2_ex_o;
    revert c_property;
    unfold projection;
    intros;
    replace #1 ((λ A B: Universe, λ S: set A, λ f2: A → B, { y: B | ∃ x: A, x ∈ S ∧ y = f2 x }) X Y C f) with ({ y | ∃ x, x ∈ C ∧ y = f x }) in c_property;
    auto_set;
    apply set_equality ;
    apply included_fold ;
    intros;
    apply set_from_func_fold ;
    add_hyp (f a ∈ { y: Y | ∃ x: X, x ∈ C ∧ y = f x });
    apply set_from_func_fold ;
    apply (ex_intro ? ? (a));
    z3;
    z3;
    apply included_fold ;
    intros;
    apply set_from_func_unfold in H ;
    assumption;
    lia;
    auto_set;
Qed;
Theorem rule_of_bijection_product2: ∀ n m, n > 0 ∧ m > 0
        -> ∀ A B C: U, ∀ f: A -> B -> C,
        ∀ P: A -> U, ∀ Q: A -> B -> U, |{a | P a}| = n -> (∀ a, P a -> |{b| Q a b}| = m)
        -> (∀ xa ya: A, ∀ xb yb: B, P xa -> P ya -> Q xa xb -> Q ya yb -> f xa xb = f ya yb -> xa = ya ∧ xb = yb)
        -> |{ y: C | ∃ a: A, ∃ b: B, y = f a b ∧ P a ∧ Q a b }| = n * m;
Proof;
    intros;
    add_hyp (∃ proj: C → A, ∀ c: C,  c ∈ {x | ∃ a: A, ∃ b: B, P a ∧ Q a b ∧ f a b = x} -> (∃ b: B, P (proj c) ∧ Q (proj c) b ∧ f (proj c) b = c));
    add_hyp (|{ a: A | P a }| > 0);
    lia;
    apply len_gt_0_not_empty_set in H3;
    destruct H3 with (ex_ind ? ?) to (d d_property);
    apply (⁨exist_function_not_total ?0 ?2 ?4 ?6 (λ c: C,   λ a: A, ∃ b: B, P a ∧ Q a b ∧ f a b = c) ?10⁩);
    intros;
    apply set_from_func_unfold in H3;
    assumption;
    assumption;
    add_hyp (∃ proj: C → B, ∀ c: C, c ∈ {t | (∃ a: A, ∃ b: B, P a ∧ Q a b ∧ f a b = t) } -> ∃ a: A, P a ∧ Q a (proj c) ∧ f a (proj c) = c);
    apply (⁨exist_function_not_total ?0 ?2 ?4 ?6 (λ c: C,   λ t: B, ∃ a: A, P a ∧ Q a t ∧ f a t = c) ?10⁩);
    intros;
    apply set_from_func_unfold in H4;
    destruct H4 with (ex_ind ? ?) to (a a_property);
    destruct a_property with (ex_ind ? ?) to (b b_property);
    apply (ex_intro ? ? (b));
    apply (ex_intro ? ? (a));
    assumption;
    add_hyp (|{ a: A | P a }| > 0);
    lia;
    apply len_gt_0_not_empty_set in H4;
    destruct H4 with (ex_ind ? ?) to (d d_property);
    add_hyp H1_ex := (H1 (d));
    apply set_from_func_unfold in d_property;
    Seq (add_hyp (⁨P d⁩)) (remove_hyp H1_ex) (Switch 1) (add_hyp H1_ex_o := (H1_ex H4)) (remove_hyp H4) (remove_hyp H1_ex);
    add_hyp (|{ x: B | Q d x }| > 0);
    lia;
    apply len_gt_0_not_empty_set in H4;
    destruct H4 with (ex_ind ? ?) to (b b_property);
    assumption;
    assumption;
    destruct H3 with (ex_ind ? ?) to (proj1 proj1_property);
    destruct H4 with (ex_ind ? ?) to (proj2 proj2_property);
    add_hyp (∀ a: A, ∀ b: B, P a -> Q a b -> proj1 (f a b) = a);
    intros;
    add_hyp proj1_property_ex := (proj1_property (f a b));
    Seq (add_hyp (⁨f a b ∈ { x: C | ∃ a0: A, ∃ b0: B, P a0 ∧ Q a0 b0 ∧ f a0 b0 = x }⁩)) (remove_hyp proj1_property_ex) (Switch 1) (add_hyp proj1_property_ex_o := (proj1_property_ex H5)) (remove_hyp H5) (remove_hyp proj1_property_ex);
    destruct proj1_property_ex_o with (ex_ind ? ?) to (b0 b0_property);
    destruct b0_property with (and_ind ? ?) to (b0_property_l b0_property_r);
    destruct b0_property_r with (and_ind ? ?) to (b0_property_r_l b0_property_r_r);
    apply H2 in b0_property_r_r;
    assumption;
    assumption;
    assumption;
    assumption;
    assumption;
    apply set_from_func_fold;
    apply (ex_intro ? ? (a));
    apply (ex_intro ? ? (b));
    z3;
    add_hyp (∀ a: A, ∀ b: B, P a → Q a b → proj2 (f a b) = b);
    intros;
    add_hyp proj2_property_ex := (proj2_property (f a b));
    Seq (add_hyp (⁨f a b ∈ { t: C | ∃ a0: A, ∃ b0: B, P a0 ∧ Q a0 b0 ∧ f a0 b0 = t }⁩)) (remove_hyp proj2_property_ex) (Switch 1) (add_hyp proj2_property_ex_o := (proj2_property_ex H6)) (remove_hyp H6) (remove_hyp proj2_property_ex);
    destruct proj2_property_ex_o with (ex_ind ? ?) to (a0 a0_property);
    destruct a0_property with (and_ind ? ?) to (a0_property_l a0_property_r);
    destruct a0_property_r with (and_ind ? ?) to (a0_property_r_l a0_property_r_r);
    apply H2 in a0_property_r_r;
    assumption;
    assumption;
    assumption;
    assumption;
    assumption;
    apply set_from_func_fold;
    apply (ex_intro ? ? (a));
    apply (ex_intro ? ? (b));
    z3;
    apply (⁨asl_zarb2 ?0 ?2 n m ?4 ?6 A proj1 ?10 ?12 ?14 ?16⁩);
    auto_list;
    intros;
    apply (⁨rule_of_bijectionR ?0 B proj2 ?4 ?6 ?8 ?10 ?12⁩);
    replace #1 (projection { x: C | x ∈ { y0: C | ∃ a: A, ∃ b: B, y0 = f a b ∧ P a ∧ Q a b } ∧ proj1 x = y } proj2) with ({ b: B | Q y b });
    apply set_equality;
    apply included_fold;
    intros;
    apply set_from_func_unfold in H6;
    apply projection_in_intro_r;
    apply (ex_intro ? ? (f y a));
    apply and_intro;
    apply eq_sym;
    apply H4;
    assumption;
    apply projection_in_intro_l in H5;
    destruct H5 with (ex_ind ? ?) to (x x_property);
    add_hyp proj1_property_ex := (proj1_property (x));
    Seq (add_hyp (⁨x ∈ { x0: C | ∃ a0: A, ∃ b: B, P a0 ∧ Q a0 b ∧ f a0 b = x0 }⁩)) (remove_hyp proj1_property_ex) (Switch 1) (add_hyp proj1_property_ex_o := (proj1_property_ex H5)) (remove_hyp H5) (remove_hyp proj1_property_ex);
    destruct proj1_property_ex_o with (ex_ind ? ?) to (b b_property);
    destruct x_property with (and_ind ? ?) to (x_property_l x_property_r);
    rewrite x_property_r;
    assumption;
    apply set_from_func_fold;
    destruct x_property with (and_ind ? ?) to (x_property_l x_property_r);
    apply set_from_func_unfold in x_property_l;
    destruct x_property_l with (ex_ind ? ?) to (a0 a0_property);
    destruct a0_property with (ex_ind ? ?) to (b0 b0_property);
    apply (ex_intro ? ? (a0));
    apply (ex_intro ? ? (b0));
    z3;
    apply set_from_func_fold;
    add_hyp (P y);
    apply projection_in_intro_l in H5;
    destruct H5 with (ex_ind ? ?) to (x x_property);
    add_hyp proj1_property_ex := (proj1_property (x));
    Seq (add_hyp (⁨x ∈ { x0: C | ∃ a0: A, ∃ b: B, P a0 ∧ Q a0 b ∧ f a0 b = x0 }⁩)) (remove_hyp proj1_property_ex) (Switch 1) (add_hyp proj1_property_ex_o := (proj1_property_ex H5)) (remove_hyp H5) (remove_hyp proj1_property_ex);
    destruct proj1_property_ex_o with (ex_ind ? ?) to (b b_property);
    destruct x_property with (and_ind ? ?) to (x_property_l x_property_r);
    rewrite x_property_r;
    assumption;
    apply set_from_func_fold;
    destruct x_property with (and_ind ? ?) to (x_property_l x_property_r);
    apply set_from_func_unfold in x_property_l;
    destruct x_property_l with (ex_ind ? ?) to (a0 a0_property);
    destruct a0_property with (ex_ind ? ?) to (b0 b0_property);
    apply (ex_intro ? ? (a0));
    apply (ex_intro ? ? (b0));
    z3;
    apply and_intro;
    apply H3;
    assumption;
    assumption;
    apply set_from_func_fold;
    apply (ex_intro ? ? (y));
    apply (ex_intro ? ? (a));
    z3;
    apply included_fold;
    intros;
    apply set_from_func_fold;
    apply projection_in_intro_l in H6;
    destruct H6 with (ex_ind ? ?) to (c c_property);
    destruct c_property with (and_ind ? ?) to (c_property_l c_property_r);
    apply set_from_func_unfold in c_property_l;
    destruct c_property_l with (and_ind ? ?) to (c_property_l_l c_property_l_r);
    apply set_from_func_unfold in c_property_l_l;
    destruct c_property_l_l with (ex_ind ? ?) to (a0 a0_property);
    destruct a0_property with (ex_ind ? ?) to (y0 y0_property);
    replace #1 (proj1 c) with (a0) in c_property_l_r;
    destruct y0_property with (and_ind ? ?) to (y0_property_l y0_property_r);
    rewrite y0_property_l;
    apply H3;
    assumption;
    assumption;
    replace #1 (proj2 c) with (y0) in c_property_r;
    destruct y0_property with (and_ind ? ?) to (y0_property_l y0_property_r);
    rewrite y0_property_l;
    apply H4;
    assumption;
    assumption;
    rewrite c_property_r;
    apply eq_sym in c_property_l_r;
    rewrite c_property_l_r;
    assumption;
    apply H1;
    apply projection_in_intro_l in H5;
    destruct H5 with (ex_ind ? ?) to (x x_property);
    add_hyp proj1_property_ex := (proj1_property (x));
    Seq (add_hyp (⁨x ∈ { x0: C | ∃ a0: A, ∃ b: B, P a0 ∧ Q a0 b ∧ f a0 b = x0 }⁩)) (remove_hyp proj1_property_ex) (Switch 1) (add_hyp proj1_property_ex_o := (proj1_property_ex H5)) (remove_hyp H5) (remove_hyp proj1_property_ex);
    destruct proj1_property_ex_o with (ex_ind ? ?) to (b b_property);
    destruct x_property with (and_ind ? ?) to (x_property_l x_property_r);
    rewrite x_property_r;
    assumption;
    apply set_from_func_fold;
    destruct x_property with (and_ind ? ?) to (x_property_l x_property_r);
    apply set_from_func_unfold in x_property_l;
    destruct x_property_l with (ex_ind ? ?) to (a0 a0_property);
    destruct a0_property with (ex_ind ? ?) to (b0 b0_property);
    apply (ex_intro ? ? (a0));
    apply (ex_intro ? ? (b0));
    z3;
    assumption;
    apply injective_fold;
    intros;
    apply set_from_func_unfold in H6;
    apply set_from_func_unfold in H7;
    destruct H6 with (and_ind ? ?) to (H6_l H6_r);
    destruct H7 with (and_ind ? ?) to (H7_l H7_r);
    apply set_from_func_unfold in H6_l;
    apply set_from_func_unfold in H7_l;
    destruct H6_l with (ex_ind ? ?) to (a a_property);
    destruct a_property with (ex_ind ? ?) to (b b_property);
    destruct H7_l with (ex_ind ? ?) to (a0 a0_property);
    destruct a0_property with (ex_ind ? ?) to (b0 b0_property);
    destruct b0_property with (and_ind ? ?) to (b0_property_l b0_property_r);
    destruct b_property with (and_ind ? ?) to (b_property_l b_property_r);
    replace #1 (proj2 x) with (b) in H8;
    rewrite b_property_l;
    apply H4;
    assumption;
    assumption;
    replace #1 (proj2 y0) with (b0) in H8;
    rewrite b0_property_l;
    apply H4;
    assumption;
    assumption;
    rewrite b0_property_l;
    rewrite b_property_l;
    replace #1 (proj1 x) with (a) in H6_r;
    rewrite b_property_l;
    apply H3;
    assumption;
    assumption;
    replace #1 (proj1 y0) with (a0) in H7_r;
    rewrite b0_property_l;
    apply H3;
    assumption;
    assumption;
    replace #1 (a) with (a0);
    auto_set;
    replace #1 (b) with (b0);
    assumption;
    auto_list;
    replace #1 (projection { y: C | ∃ a: A, ∃ b: B, y = f a b ∧ P a ∧ Q a b } proj1) with ({ a: A | P a });
    apply set_equality;
    apply included_fold;
    intros;
    apply projection_in_intro_r;
    apply set_from_func_unfold in H5;
    add_hyp H1_ex := (H1 (a));
    Seq (add_hyp (⁨P a⁩)) (remove_hyp H1_ex) (Switch 1) (add_hyp H1_ex_o := (H1_ex H6)) (remove_hyp H6) (remove_hyp H1_ex);
    add_hyp (|{ x: B | Q a x }| > 0);
    lia;
    apply len_gt_0_not_empty_set in H6;
    destruct H6 with (ex_ind ? ?) to (b b_property);
    apply set_from_func_unfold in b_property;
    apply (ex_intro ? ? (f a b));
    apply and_intro;
    apply eq_sym;
    apply H3;
    assumption;
    assumption;
    apply set_from_func_fold;
    apply (ex_intro ? ? (a));
    apply (ex_intro ? ? (b));
    z3;
    assumption;
    apply included_fold;
    intros;
    apply projection_in_intro_l in H5;
    apply set_from_func_fold;
    destruct H5 with (ex_ind ? ?) to (x x_property);
    destruct x_property with (and_ind ? ?) to (x_property_l x_property_r);
    apply set_from_func_unfold in x_property_l;
    destruct x_property_l with (ex_ind ? ?) to (a0 a0_property);
    destruct a0_property with (ex_ind ? ?) to (b b_property);
    replace #2 (a0) with (a) in b_property;
    rewrite x_property_r;
    destruct b_property with (and_ind ? ?) to (b_property_l b_property_r);
    rewrite b_property_l;
    apply eq_sym;
    apply H3;
    assumption;
    assumption;
    assumption;
    assumption;
    assumption;
    assumption;
Qed;

Theorem asl_zarb3: ∀ n m, n > 0 ∧ m > 0
     	-> ∀ A B: U, ∀ C: A -> B -> U,
        ∀ P: A -> U, |{a | P a}| = n -> (∀ a, P a -> |{b| C a b}| = m)
        -> (∀ xa ya: A, ∀ xb yb: B, xb = yb -> C xa xb -> C ya yb -> xa = ya)
        -> (∀ a, (∃ b, C a b) -> P a)
        -> |{ b: B | ∃ a: A, C a b }| = m * n;
Proof;
    intros;
    add_from_lib exist_function_not_total;
    add_hyp exist_function_not_total_ex := (exist_function_not_total (B));
    add_hyp exist_function_not_total_ex_ex := (exist_function_not_total_ex (A));
    Seq (add_hyp (⁨A⁩)) (remove_hyp exist_function_not_total_ex_ex) (Switch 1) (add_hyp exist_function_not_total_ex_ex_o := (exist_function_not_total_ex_ex H4)) (remove_hyp H4) (remove_hyp exist_function_not_total_ex_ex);
    add_hyp exist_function_not_total_ex_ex_o_ex := (exist_function_not_total_ex_ex_o ({ b: B | ∃ a: A, C a b }));
    add_hyp exist_function_not_total_ex_ex_o_ex_ex := (exist_function_not_total_ex_ex_o_ex (λ b, λ a, C a b));
    Seq (add_hyp (⁨∀ x: B, x ∈ { b: B | ∃ a: A, C a b } → ∃ x0: A, (λ b: B, λ a: A, C a b) x x0⁩)) (remove_hyp exist_function_not_total_ex_ex_o_ex_ex) (Switch 1) (add_hyp exist_function_not_total_ex_ex_o_ex_ex_o := (exist_function_not_total_ex_ex_o_ex_ex H4)) (remove_hyp H4) (remove_hyp exist_function_not_total_ex_ex_o_ex_ex);
    destruct exist_function_not_total_ex_ex_o_ex_ex_o with (ex_ind ? ?) to (f f_property);
    remove_hyp exist_function_not_total_ex_ex_o_ex;
    remove_hyp exist_function_not_total_ex_ex_o;
    remove_hyp exist_function_not_total_ex;
    apply (⁨asl_zarb2 ?0 ?2 n m ?4 ?6 A f ?10 ?12 ?14 ?16⁩);
    lia;
    intros;
    add_hyp H1_ex := (H1 (y));
    Seq (add_hyp (⁨P y⁩)) (remove_hyp H1_ex) (Switch 1) (add_hyp H1_ex_o := (H1_ex H5)) (remove_hyp H5) (remove_hyp H1_ex);
    replace #1 ({ x: B | x ∈ { b: B | ∃ a: A, C a b } ∧ f x = y }) with ({ x: B | C y x });
    apply set_from_func_eq;
    intros;
    apply and_intro;
    intros;
    add_hyp (x ∈ { b: B | ∃ a: A, C a b });
    apply set_from_func_fold;
    apply (ex_intro ? ? (y));
    assumption;
    add_hyp f_property_ex := (f_property (x));
    Seq (add_hyp (⁨x ∈ { b: B | ∃ a: A, C a b }⁩)) (remove_hyp f_property_ex) (Switch 1) (add_hyp f_property_ex_o := (f_property_ex H7)) (remove_hyp H7) (remove_hyp f_property_ex);
    apply and_intro;
    apply (⁨H2 ?0 ?2 x x ?6 ?8 ?10⁩);
    assumption;
    assumption;
    auto_list;
    assumption;
    assumption;
    intros;
    add_hyp f_property_ex := (f_property (x));
    Seq (add_hyp (⁨x ∈ { b: B | ∃ a: A, C a b }⁩)) (remove_hyp f_property_ex) (Switch 1) (add_hyp f_property_ex_o := (f_property_ex H6)) (remove_hyp H6) (remove_hyp f_property_ex);
    replace #1 ((f x)) with (y) in f_property_ex_o;
    assumption;
    assumption;
    assumption;
    assumption;
    apply projection_in_intro_l in H4;
    apply H3;
    destruct H4 with (ex_ind ? ?) to (x x_property);
    apply (ex_intro ? ? (x));
    destruct x_property with (and_ind ? ?) to (x_property_l x_property_r) ;
    rewrite x_property_r ;
    apply f_property;
    assumption;
    replace #1 (projection { b: B | ∃ a: A, C a b } f) with ({ a: A | P a });
    apply set_equality ;
    apply included_fold ;
    intros;
    apply set_from_func_unfold in H4 ;
    apply projection_in_intro_r ;
    add_hyp H1_ex := (H1 (a));
    Seq (add_hyp (⁨P a⁩)) (remove_hyp H1_ex) (Switch 1) (add_hyp H1_ex_o := (H1_ex H5)) (remove_hyp H5) (remove_hyp H1_ex) ;
    add_hyp (|{ x: B | C a x }| > 0);
    lia;
    apply len_gt_0_not_empty_set in H5;
    destruct H5 with (ex_ind ? ?) to (x x_property);
    apply set_from_func_unfold in x_property ;
    apply (ex_intro ? ? (x));
    add_hyp (x ∈ { b: B | ∃ a0: A, C a0 b });
    apply set_from_func_fold ;
    apply (ex_intro ? ? (a));
    assumption;
    add_hyp f_property_ex := (f_property (x));
    Seq (add_hyp (⁨x ∈ { b: B | ∃ a0: A, C a0 b }⁩)) (remove_hyp f_property_ex) (Switch 1) (add_hyp f_property_ex_o := (f_property_ex H6)) (remove_hyp H6) (remove_hyp f_property_ex) ;
    apply and_intro ;
    apply (⁨H2 ?0 ?2 x x ?6 ?8 ?10⁩);
    assumption;
    assumption;
    auto_list;
    assumption;
    assumption;
    assumption;
    apply included_fold ;
    intros;
    apply set_from_func_fold ;
    apply projection_in_intro_l in H4 ;
    add_hyp H3_ex := (H3 (a));
    Seq (add_hyp (⁨∃ x: B, C a x⁩)) (remove_hyp H3_ex) (Switch 1) (add_hyp H3_ex_o := (H3_ex H5)) (remove_hyp H5) (remove_hyp H3_ex) ;
    assumption;
    destruct H4 with (ex_ind ? ?) to (x x_property);
    apply (ex_intro ? ? (x));
    destruct x_property with (and_ind ? ?) to (x_property_l x_property_r) ;
    apply set_from_func_unfold in x_property_l ;
    add_hyp f_property_ex := (f_property (x));
    Seq (add_hyp (⁨x ∈ { b: B | ∃ a0: A, C a0 b }⁩)) (remove_hyp f_property_ex) (Switch 1) (add_hyp f_property_ex_o := (f_property_ex H4)) (remove_hyp H4) (remove_hyp f_property_ex) ;
    rewrite x_property_r ;
    assumption;
    apply set_from_func_fold;
    assumption;
    assumption;
    assumption;
    assumption;
    intros;
    apply set_from_func_unfold in H4 ;
    assumption;
    add_hyp (|{ a: A | P a }|>0);
    lia;
    apply len_gt_0_not_empty_set in H4;
    destruct H4 with (ex_ind ? ?) to (t t_property);
    assumption;
Qed;
Axiom cm: ℤ -> ℤ -> ℤ;
Axiom cm0: ∀ r, 0 ≤ r -> cm r 0 = 1;
Axiom cmeq: ∀ r, 0 ≤ r -> cm r r = 1;
Axiom cmdefr: ∀ a b, 0 < a -> 0 < b -> b < a -> cm a b = cm (a - 1) b + cm (a - 1) (b - 1);
Axiom cm2: ∀ r, 2 * cm r 2 = r * (r - 1);
Todo cm_not_neg: ∀ n r, r ≤ n -> 0 ≤ r -> 0 ≤ cm n r;
Todo cm_gt: ∀ n r, 2 * r < n -> 0 ≤ r -> cm n r < cm n (r + 1);

Theorem sigma_0_n: ∀ n, (Σ i in [0, n) i) = cm n 2;
Proof;
    add_hyp (∀ n0: ℤ, 0 ≤ n0 → (Σ i in [0, n0) i) = cm n0 2);
    apply z_induction_simple;
    intros;
    add_from_lib cm2;
    add_hyp cm2_ex := (cm2 (n));
    add_hyp cm2_ex0 := (cm2 (n+1));
    lia;
    add_from_lib cm2;
    add_hyp cm2_ex := (cm2 (0));
    lia;
    intros;
    add_hyp (n < 0 ∨ n ≥ 0);
    lia;
    destruct H0 with (or_ind ? ?);
    apply H;
    assumption;
    add_hyp (∀ x, 0 ≤ x -> (Σ i in [0, - x) i) = cm (- x) 2);
    apply z_induction_simple;
    intros;
    add_from_lib cm2;
    add_hyp cm2_ex := (cm2 (-n0));
    add_hyp cm2_ex0 := (cm2 (-(n0+1)));
    lia;
    add_from_lib cm2;
    add_hyp cm2_ex := (cm2 (-0));
    lia;
    add_hyp (∃ k, k = - n);
    apply (ex_intro ? ? (-n));
    auto_list;
    destruct H2 with (ex_ind ? ?) to (k k_property);
    add_hyp (n = -k);
    lia;
    rewrite H2;
    apply H1;
    lia;
Qed;

Theorem binomial_coefficients: ∀ n, 0 ≤ n -> ∀ a b, (a+b) ^ n = (Σ i in [0, n + 1) cm n i * a ^ i * b ^ (n - i));
Proof;
    apply z_induction_simple;
    Switch 1;
    intros;
    replace #1 (Σ i in [0, 0 + 1) cm 0 i * a ^ i * b ^ (0 - i)) with (Σ i in [0, 0 + 1) 1);
    apply sigma_f_equal;
    intros;
    replace #1 (cm 0 i) with (1);
    replace #1 (i) with (0);
    lia;
    apply cm0;
    auto_list;
    replace #1 ((0 - i)) with ((0));
    lia;
    replace #1 (a ^ i) with (1);
    replace #1 (i) with (0);
    lia;
    lia;
    lia;
    lia;
    lia;
    intros;
    add_hyp H0_ex := (H0 (a));
    add_hyp H0_ex_ex := (H0_ex (b));
    add_hyp ((a + b) * (a + b) ^ n = a * (Σ i in [0, n + 1) cm n i * a ^ i * b ^ (n - i)) + b * Σ i0 in [0, n + 1) cm n i0 * a ^ i0 * b ^ (n - i0));
    replace #1 (a * (Σ i in [0, n + 1) cm n i * a ^ i * b ^ (n - i)) + b * Σ i0 in [0, n + 1) cm n i0 * a ^ i0 * b ^ (n - i0)) with ((a+b) * (Σ i in [0, n + 1) cm n i * a ^ i * b ^ (n - i)));
    lia;
    rewrite H0_ex_ex;
    auto_list;
    replace #1 ((a + b) ^ (n + 1)) with ((a+b)*(a + b) ^ n);
    apply pow_unfold_l;
    assumption;
    rewrite H1;
    replace #1 (a * (Σ i in [0, n + 1) cm n i * a ^ i * b ^ (n - i))) with ( (Σ i in [0, n + 1) a * cm n i * a ^ i * b ^ (n - i)));
    replace #1 (Σ i in [0, n + 1) a * cm n i * a ^ i * b ^ (n - i)) with (Σ i in [0, n + 1) a * (cm n i * a ^ i * b ^ (n - i)));
    apply sigma_f_equal;
    intros;
    lia;
    lia;
    apply sigma_factor;
    replace #1 (b * (Σ i0 in [0, n + 1) cm n i0 * a ^ i0 * b ^ (n - i0))) with ((Σ i0 in [0, n + 1) cm n i0 * a ^ i0 * b ^ (n - i0 + 1)));
    replace #1 (Σ i0 in [0, n + 1) cm n i0 * a ^ i0 * b ^ (n - i0 + 1)) with (Σ i0 in [0, n + 1) b * (cm n i0 * a ^ i0 * b ^ (n - i0)));
    apply sigma_f_equal;
    intros;
    replace #1 (b ^ (n - i + 1)) with (b * b ^ (n - i));
    apply pow_unfold_l;
    lia;
    lia;
    lia;
    apply sigma_factor;
    replace #1 ((Σ i in [0, n + 1) a * cm n i * a ^ i * b ^ (n - i))) with ((Σ i in [0, n + 1) cm n i * a ^ (i+1) * b ^ (n - (i+1) + 1)));
    apply sigma_f_equal;
    intros;
    replace #1 (a ^ (i + 1)) with (a * a ^ i);
    apply pow_unfold_l;
    assumption;
    lia;
    lia;
    replace #1 ((Σ i in [0, n + 1) cm n i * a ^ (i + 1) * b ^ (n - (i + 1) + 1))) with ((Σ i in [0+1, n + 1 +1) cm n (i-1) * a ^ i * b ^ (n - i + 1)));
    apply sigma_shift;
    replace #1 ((Σ i in [0 + 1, n + 1 + 1) cm n (i - 1) * a ^ i * b ^ (n - i + 1))) with ((Σ i in [0 + 1, n + 1) cm n (i - 1) * a ^ i * b ^ (n - i + 1)) + cm n n * a ^ (n+1) * b ^ (n - (n+1) + 1));
    lia;
    replace #1 (cm n n * a ^ (n + 1) * b ^ (n - (n + 1) + 1)) with (a ^ (n + 1));
    add_from_lib cmeq;
    add_hyp cmeq_ex := (cmeq (n));
    replace #1 ((n - (n + 1) + 1)) with (0);
    lia;
    add_hyp (⁨0 ≤ n⁩);
    remove_hyp cmeq_ex;
    Switch 1;
    add_hyp cmeq_ex_o := (cmeq_ex H2);
    remove_hyp H2;
    remove_hyp cmeq_ex;
    rewrite cmeq_ex_o;
    lia;
    assumption;
    replace #1 ((Σ i0 in [0, n + 1) cm n i0 * a ^ i0 * b ^ (n - i0 + 1))) with ((Σ i0 in [1, n + 1) cm n i0 * a ^ i0 * b ^ (n - i0 + 1)) + cm n 0 * a ^ 0 * b ^ (n - 0 + 1));
    lia;
    replace #1 (cm n 0 * a ^ 0 * b ^ (n - 0 + 1)) with (b ^ (n - 0 + 1));
    add_from_lib cm0;
    add_hyp cm0_ex := (cm0 (n));
    add_hyp (⁨0 ≤ n⁩);
    remove_hyp cm0_ex;
    Switch 1;
    add_hyp cm0_ex_o := (cm0_ex H2);
    remove_hyp H2;
    remove_hyp cm0_ex;
    rewrite cm0_ex_o;
    lia;
    assumption;
    replace #1 ((Σ i in [0 + 1, n + 1) cm n (i - 1) * a ^ i * b ^ (n - i + 1)) + a ^ (n + 1) + ((Σ i0 in [1, n + 1) cm n i0 * a ^ i0 * b ^ (n - i0 + 1)) + b ^ (n - 0 + 1))) with ((Σ i in [1, n + 1) cm n (i - 1) * a ^ i * b ^ (n - i + 1)) + ((Σ i0 in [1, n + 1) cm n i0 * a ^ i0 * b ^ (n - i0 + 1)) + a ^ (n + 1) + b ^ (n - 0 + 1)));
    lia;
    replace #1 ((Σ i in [1, n + 1) cm n (i - 1) * a ^ i * b ^ (n - i + 1)) + ((Σ i0 in [1, n + 1) cm n i0 * a ^ i0 * b ^ (n - i0 + 1)) + a ^ (n + 1) + b ^ (n - 0 + 1))) with ((Σ i in [1, n + 1) cm n (i - 1) * a ^ i * b ^ (n - i + 1)) + (Σ i0 in [1, n + 1) cm n i0 * a ^ i0 * b ^ (n - i0 + 1)) + a ^ (n + 1) + b ^ (n - 0 + 1));
    lia;
    replace #1 ((Σ i in [1, n + 1) cm n (i - 1) * a ^ i * b ^ (n - i + 1)) + (Σ i0 in [1, n + 1) cm n i0 * a ^ i0 * b ^ (n - i0 + 1))) with ((Σ i in [1, n + 1) cm n (i - 1) * a ^ i * b ^ (n - i + 1) + cm n i * a ^ i * b ^ (n - i + 1)));
    apply sigma_plus2;
    replace #1 ((Σ i in [1, n + 1) cm n (i - 1) * a ^ i * b ^ (n - i + 1) + cm n i * a ^ i * b ^ (n - i + 1))) with ((Σ i in [1, n + 1) (cm n (i - 1) + cm n i) * a ^ i * b ^ (n - i + 1)));
    apply sigma_f_equal;
    intros;
    lia;
    lia;
    replace #1 ((Σ i in [1, n + 1) (cm n (i - 1) + cm n i) * a ^ i * b ^ (n - i + 1))) with ((Σ i in [1, n + 1) (cm (n+1) i) * a ^ i * b ^ (n - i + 1)));
    apply sigma_f_equal;
        intros;
    add_from_lib cmdefr;
    add_hyp cmdefr_ex := (cmdefr (n+1));
    add_hyp cmdefr_ex_ex := (cmdefr_ex (i));
    add_hyp (⁨0 < n + 1⁩);
    remove_hyp cmdefr_ex_ex;
    Switch 1;
    add_hyp cmdefr_ex_ex_o := (cmdefr_ex_ex H4);
    remove_hyp H4;
    remove_hyp cmdefr_ex_ex;
    add_hyp (⁨0 < i⁩);
    remove_hyp cmdefr_ex_ex_o;
    Switch 1;
    add_hyp cmdefr_ex_ex_o_o := (cmdefr_ex_ex_o H4);
    remove_hyp H4;
    remove_hyp cmdefr_ex_ex_o;
    add_hyp (⁨i < n + 1⁩);
    remove_hyp cmdefr_ex_ex_o_o;
    Switch 1;
    add_hyp cmdefr_ex_ex_o_o_o := (cmdefr_ex_ex_o_o H4);
    remove_hyp H4;
    remove_hyp cmdefr_ex_ex_o_o;
    replace #1 ((n + 1 - 1)) with (n) in cmdefr_ex_ex_o_o_o;
    lia;
    replace #1 ((n + 1 - 1)) with (n) in cmdefr_ex_ex_o_o_o;
    lia;
    apply eq_sym in cmdefr_ex_ex_o_o_o;
    apply eq_sym in cmdefr_ex_ex_o_o_o;
    rewrite cmdefr_ex_ex_o_o_o;
    lia;
    assumption;
    lia;
    lia;
    lia;
    replace #1 (n - 0 + 1) with (n+1);
    lia;
    replace #1 (Σ i in [0, n + 1 + 1) cm (n + 1) i * a ^ i * b ^ (n + 1 - i)) with (cm (n + 1) 0 * a ^ 0 * b ^ (n + 1 - 0) + Σ i in [1, n + 1 + 1) cm (n + 1) i * a ^ i * b ^ (n + 1 - i));
    lia;
    replace #1 (Σ i in [1, n + 1 + 1) cm (n + 1) i * a ^ i * b ^ (n + 1 - i)) with (cm (n + 1) (n + 1) * a ^ (n + 1) * b ^ (n + 1 - (n + 1)) + Σ i in [1, n + 1) cm (n + 1) i * a ^ i * b ^ (n + 1 - i));
    lia;
    replace #1 (cm (n + 1) 0 * a ^ 0 * b ^ (n + 1 - 0)) with (b^(n+1));
    Switch 1;
    replace #1 (cm (n + 1) (n + 1) * a ^ (n + 1) * b ^ (n + 1 - (n + 1))) with (a^(n+1));
    Switch 1;
    replace #1 (Σ i in [1, n + 1) cm (n + 1) i * a ^ i * b ^ (n + 1 - i)) with (Σ i in [1, n + 1) cm (n + 1) i * a ^ i * b ^ (n - i + 1));
    Switch 1;
    lia;
    apply sigma_f_equal;
    intros;
    lia;
    lia;
    add_from_lib cmeq;
    add_hyp cmeq_ex := (cmeq (n+1));
    add_hyp (⁨0 ≤ n + 1⁩);
    remove_hyp cmeq_ex;
    Switch 1;
    add_hyp cmeq_ex_o := (cmeq_ex H2);
    remove_hyp H2;
    remove_hyp cmeq_ex;
    rewrite cmeq_ex_o;
    replace #1 ((n + 1 - (n + 1))) with (0);
    lia;
    lia;
    lia;
    add_from_lib cm0;
    add_hyp cm0_ex := (cm0 (n+1));
    add_hyp (⁨0 ≤ n + 1⁩);
    remove_hyp cm0_ex;
    Switch 1;
    add_hyp cm0_ex_o := (cm0_ex H2);
    remove_hyp H2;
    remove_hyp cm0_ex;
    rewrite cm0_ex_o;
    lia;
    lia;
Qed;

Theorem sigma_cm_n: ∀ n, 0 ≤ n -> (Σ i in [0, n + 1) cm n i) = 2 ^ n;
Proof;
    intros;
    add_from_lib binomial_coefficients;
    add_hyp binomial_coefficients_ex := (binomial_coefficients (n));
    Seq (add_hyp (0 ≤ n)) (remove_hyp binomial_coefficients_ex) (Switch 1) (add_hyp binomial_coefficients_ex_o := (binomial_coefficients_ex H0)) (remove_hyp H0) (remove_hyp binomial_coefficients_ex);
    add_hyp binomial_coefficients_ex_o_ex := (binomial_coefficients_ex_o (1));
    add_hyp binomial_coefficients_ex_o_ex_ex := (binomial_coefficients_ex_o_ex (1));
    lia;
    assumption;
Qed;

Todo cnt_of_map: ∀ X Y: U, ∀ f: X -> Y, ∀ S, ∀ l, injective f S -> (member_set l) ⊆ S -> ∀ a, a ∈ S -> cnt (f a) (map f l) = cnt a l;

Todo count_of_paths: ∀ r, 0 ≤ r -> ∀ u, 0 ≤ u -> |{ l: list char | cnt 'r' l = r ∧ cnt 'u' l = u ∧ |l| = r + u }| = cm (r+u) u;
Todo member_set_is_two_element_l: ∀ T: U, ∀ l: list T, ∀ a b, |l| = cnt a l + cnt b l -> member_set l ⊆ {a, b};
Todo member_set_is_two_element_r: ∀ T: U, ∀ l: list T, ∀ a b, member_set l ⊆ {a, b} -> |l| = cnt a l + cnt b l;


Axiom valid_paren: list char -> Universe;
Axiom valid_paren_unfold: ∀ l, valid_paren l -> l = "" ∨ ∃ x y, valid_paren x ∧ valid_paren y ∧ l = "(" + x + ")" + y;
Suggest hyp default apply valid_paren_unfold in $n with label Destruct;
Axiom valid_paren_fold: ∀ l, (∃ x y, valid_paren x ∧ valid_paren y ∧ l = "(" + x + ")" + y) -> valid_paren l;
Axiom valid_paren_empty: valid_paren "";
Todo valid_paren_elements_type: ∀ l, valid_paren l -> ∀ a, a in l -> a = '(' ∨ a = ')';
Theorem valid_paren_wrap: ∀ l, valid_paren l -> valid_paren ("(" + l + ")");
Proof;
    intros;
    apply valid_paren_fold;
    apply (ex_intro ? ? (l));
    apply (ex_intro ? ? (""));
    apply and_intro;
    apply and_intro;
    auto_list;
    Switch 1;
    assumption;
    apply valid_paren_empty;
Qed;
Theorem valid_paren_concat: ∀ a b, valid_paren a -> valid_paren b -> valid_paren (a + b);
Proof;
    apply list_induction_len;
    intros;
    apply valid_paren_unfold in H0;
    destruct H0 with (or_ind ? ?);
    destruct H0 with (ex_ind ? ?) to (x x_property);
    destruct x_property with (ex_ind ? ?) to (y y_property);
    destruct y_property with (and_ind ? ?) to (y_property_l y_property_r);
    destruct y_property_r with (and_ind ? ?) to (y_property_r_l y_property_r_r);
    rewrite y_property_r_r;
    apply valid_paren_fold;
    apply (ex_intro ? ? (x));
    apply (ex_intro ? ? (y+b0));
    apply and_intro;
    apply and_intro;
    auto_list;
    apply H;
    assumption;
    assumption;
    rewrite y_property_r_r;
    apply list_len_concat_lt;
    auto_list;
    assumption;
    rewrite H0;
    replace #1 (("" + b0)) with (b0);
    auto_list;
    assumption;
Qed;
Suggest goal default apply valid_paren_wrap with label valid_paren ("(" + l + ")") => valid_paren l;
Suggest goal default apply valid_paren_concat with label valid_paren (a + b) => valid_paren a ∧ valid_paren b;
Theorem valid_paren_len_even: ∀ a, valid_paren a -> 2 | |a|;
Proof;
    apply list_induction_len;
    intros;
    apply valid_paren_unfold in H0;
    destruct H0 with (or_ind ? ?);
    destruct H0 with (ex_ind ? ?) to (x x_property);
    destruct x_property with (ex_ind ? ?) to (y y_property);
    destruct y_property with (and_ind ? ?) to (y_property_l y_property_r);
    destruct y_property_r with (and_ind ? ?) to (y_property_r_l y_property_r_r);
    replace #1 (b) with ("(" + x + ")" + y) in H;
    assumption;
    apply H in y_property_r_l;
    lia;
    apply H in y_property_l;
    lia;
    replace #1 (|b|) with (|x|+|y|+2);
    rewrite y_property_r_r;
    lia;
    apply divide_plus;
    apply divide_fold;
    apply (ex_intro ? ? (1));
    lia;
    apply divide_plus;
    assumption;
    assumption;
    rewrite H0;
    apply divide_fold;
    apply (ex_intro ? ? (0));
    lia;
Qed;
Theorem valid_paren_single: valid_paren "()";
Proof;
    replace #1 ("()") with ("("+""+")");
    auto_list;
    apply valid_paren_wrap;
    apply valid_paren_empty;
Qed;
Theorem valid_paren_cnt_left: ∀ a, valid_paren a -> ∀ k, 2 * k = |a| -> cnt '(' a = k;
Proof;
    apply list_induction_len;
    intros;
    apply valid_paren_unfold in H0;
    destruct H0 with (or_ind ? ?);
    destruct H0 with (ex_ind ? ?) to (x x_property);
    destruct x_property with (ex_ind ? ?) to (y y_property);
    destruct y_property with (and_ind ? ?) to (y_property_l y_property_r);
    destruct y_property_r with (and_ind ? ?) to (y_property_r_l y_property_r_r);
    replace #1 (b) with ("(" + x + ")" + y) in H;
    assumption;
    add_from_lib valid_paren_len_even;
    add_hyp valid_paren_len_even_ex := (valid_paren_len_even (x));
    add_hyp valid_paren_len_even_ex0 := (valid_paren_len_even (y));
    add_hyp (⁨valid_paren x⁩);
    remove_hyp valid_paren_len_even_ex;
    Switch 1;
    add_hyp valid_paren_len_even_ex_o := (valid_paren_len_even_ex H0);
    remove_hyp H0;
    remove_hyp valid_paren_len_even_ex;
    add_hyp (⁨valid_paren y⁩);
    remove_hyp valid_paren_len_even_ex0;
    Switch 1;
    add_hyp valid_paren_len_even_ex0_o := (valid_paren_len_even_ex0 H0);
    remove_hyp H0;
    remove_hyp valid_paren_len_even_ex0;
    apply divide_unfold in valid_paren_len_even_ex_o;
    apply divide_unfold in valid_paren_len_even_ex0_o;
    destruct valid_paren_len_even_ex_o with (ex_ind ? ?) to (cx cx_property);
    destruct valid_paren_len_even_ex0_o with (ex_ind ? ?) to (cy cy_property);
    add_hyp H_ex := (H (x));
    add_hyp H_ex0 := (H (y));
    add_hyp (⁨|x| < |"(" + x + ")" + y|⁩);
    remove_hyp H_ex;
    Switch 1;
    add_hyp H_ex_o := (H_ex H0);
    remove_hyp H0;
    remove_hyp H_ex;
    add_hyp (⁨|y| < |"(" + x + ")" + y|⁩);
    remove_hyp H_ex0;
    Switch 1;
    add_hyp H_ex0_o := (H_ex0 H0);
    remove_hyp H0;
    remove_hyp H_ex0;
    add_hyp (⁨valid_paren x⁩);
    remove_hyp H_ex_o;
    Switch 1;
    add_hyp H_ex_o_o := (H_ex_o H0);
    remove_hyp H0;
    remove_hyp H_ex_o;
    add_hyp (⁨valid_paren y⁩);
    remove_hyp H_ex0_o;
    Switch 1;
    add_hyp H_ex0_o_o := (H_ex0_o H0);
    remove_hyp H0;
    remove_hyp H_ex0_o;
    add_hyp H_ex_o_o_ex := (H_ex_o_o (cx));
    add_hyp H_ex0_o_o_ex := (H_ex0_o_o (cy));
    add_hyp (⁨2 * cx = |x|⁩);
    remove_hyp H_ex_o_o_ex;
    Switch 1;
    add_hyp H_ex_o_o_ex_o := (H_ex_o_o_ex H0);
    remove_hyp H0;
    remove_hyp H_ex_o_o_ex;
    add_hyp (⁨2 * cy = |y|⁩);
    remove_hyp H_ex0_o_o_ex;
    Switch 1;
    add_hyp H_ex0_o_o_ex_o := (H_ex0_o_o_ex H0);
    remove_hyp H0;
    remove_hyp H_ex0_o_o_ex;
    rewrite y_property_r_r;
    replace #1 (k) with (cx+cy+1);
    Switch 1;
    lia;
    add_hyp (2*k=2*cx+2*cy+2);
    rewrite H1;
    rewrite cx_property;
    rewrite cy_property;
    rewrite y_property_r_r;
    lia;
    lia;
    assumption;
    assumption;
    assumption;
    assumption;
    lia;
    lia;
    assumption;
    assumption;
    replace #1 (|b|) with (0) in H1;
    rewrite H0;
    lia;
    replace #1 (k) with (0);
    lia;
    rewrite H0;
    lia;
Qed;
Todo valid_paren_cnt_right: ∀ a, valid_paren a -> ∀ k, 2 * k = |a| -> cnt ')' a = k;

Theorem count_of_lists: ∀ T: U, ∀ S: set T, ∀ m, 0 < m -> |S| = m -> ∀ n, 0 ≤ n -> |{ l: list T | member_set l ⊆ S ∧ |l| = n }| = m ^ n;
Proof;
    intros;
    apply eq_sym in H0;
    rewrite H0;
    apply eq_sym in H0;
    add_hyp (∃ x: T, x ∈ S);
    apply len_gt_0_not_empty_set;
    lia;
    destruct H2 with (ex_ind ? ?) to (d d_property);
    remove_hyp d_property;
    revert H0;
    revert H;
    revert m;
    revert S;
    revert H1;
    revert n;
    apply z_induction_simple;
    Switch 1;
    intros;
    replace #1 ({ l: list T | member_set l ⊆ S ∧ |l| = 0 }) with ({nil T});
    apply set_equality;
    apply included_fold;
    intros;
    apply singleton_unfold in H1;
    apply eq_sym in H1;
    rewrite H1;
    apply set_from_func_fold;
    apply and_intro;
    lia;
    replace #1 (member_set []) with (set_empty T);
    apply member_set_empty;
    auto_set;
    apply included_fold;
    intros;
    apply set_from_func_unfold in H1;
    destruct H1 with (and_ind ? ?) to (H1_l H1_r);
    apply nil_unique in H1_r;
    auto_set;
    replace #1 (|S| ^ 0) with (1);
    lia;
    apply singleton_len;
    intros;
    apply (⁨asl_zarb2 ?0 ?2 (|S|) (|S| ^ n) ?8 ?10 T (head d) ?14 ?16 ?18 ?20⁩);
    apply pow_unfold_l;
    assumption;
    intros;
    add_hyp (y ∈S);
    apply projection_in_intro_l in H2;
    destruct H2 with (ex_ind ? ?) to (x x_property);
    destruct x_property with (and_ind ? ?) to (x_property_l x_property_r);
    apply set_from_func_unfold in x_property_l;
    destruct x;
    lia;
    replace #1 (head d (x0 :: l)) with (x0) in x_property_r;
    auto_list;
    replace #1 (x0) with (y) in x_property_l;
    auto_set;
    destruct x_property_l with (and_ind ? ?) to (x_property_l_l x_property_l_r);
    add_hyp (y ∈ member_set (y :: l));
    apply member_set_cons;
    auto_set;
    apply (⁨rule_of_bijectionR ?0 (list T) tail ?4 ?6 ?8 ?10 ?12⁩);
    replace #1 (projection { x: list T | x ∈ { l: list T | member_set l ⊆ S ∧ |l| = n + 1 } ∧ head d x = y } tail) with ({ l: list T | member_set l ⊆ S ∧ |l| = n });
    apply set_equality;
    apply included_fold;
    intros;
    apply projection_in_intro_r;
    apply (ex_intro ? ? (y :: a));
    apply and_intro;
    auto_list;
    apply set_from_func_unfold in H4;
    apply set_from_func_fold;
    destruct H4 with (and_ind ? ?) to (H4_l H4_r);
    apply and_intro;
    auto_list;
    apply set_from_func_fold;
    apply and_intro;
    lia;
    replace #1 (member_set (y :: a)) with ({y} ∪ member_set ( a));
    apply member_set_cons_union;
    auto_set;
    apply included_fold;
    intros;
    apply set_from_func_fold;
    apply projection_in_intro_l in H4;
    destruct H4 with (ex_ind ? ?) to (x x_property);
    destruct x_property with (and_ind ? ?) to (x_property_l x_property_r);
    apply set_from_func_unfold in x_property_l;
    destruct x_property_l with (and_ind ? ?) to (x_property_l_l x_property_l_r);
    apply set_from_func_unfold in x_property_l_l;
    destruct x_property_l_l with (and_ind ? ?) to (x_property_l_l_l x_property_l_l_r);
    destruct x;
    lia;
    replace #1 (head d (x0 :: l)) with (x0) in x_property_l_r;
    auto_list;
    replace #1 (x0) with (y) in x_property_l_l_r;
    assumption;
    replace #1 (x0) with (y) in x_property_l_l_l;
    assumption;
    replace #1 (x0) with (y) in x_property_r;
    assumption;
    replace #1 (tail (y :: l)) with (l) in x_property_r;
    auto_list;
    rewrite x_property_r;
    apply and_intro;
    lia;
    replace #1 (member_set (y :: l)) with ({y} ∪ member_set ( l)) in x_property_l_l_l;
    apply member_set_cons_union;
    auto_set;
    apply (⁨H0 ?0 m ?4 ?6⁩);
    assumption;
    assumption;
    apply pow_not_neg;
    lia;
    assumption;
    apply injective_fold;
    intros;
    apply set_from_func_unfold in H4;
    apply set_from_func_unfold in H5;
    destruct H4 with (and_ind ? ?) to (H4_l H4_r);
    apply set_from_func_unfold in H4_l;
    destruct H5 with (and_ind ? ?) to (H5_l H5_r);
    apply set_from_func_unfold in H5_l;
    destruct x;
    lia;
    destruct y0;
    lia;
    replace #1 (tail (x0 :: l)) with (l) in H6;
    auto_list;
    replace #1 (tail (x :: l0)) with (l0) in H6;
    auto_list;
    replace #1 (head d (x0 :: l)) with (x0) in H4_r;
    auto_list;
    replace #1 (head d (x :: l0)) with (x) in H5_r;
    auto_list;
    rewrite H6;
    rewrite H4_r;
    rewrite H5_r;
    auto_list;
    replace #1 (projection { l: list T | member_set l ⊆ S ∧ |l| = n + 1 } (head d)) with (S);
    apply set_equality;
    apply included_fold;
    intros;
    apply projection_in_intro_r;
    apply (ex_intro ? ? (repeat (n + 1) a));
    apply and_intro;
    apply eq_sym;
    apply repeat_head;
    lia;
    apply set_from_func_fold;
    apply and_intro;
    apply repeat_len;
    lia;
    replace #1 (member_set (repeat (n + 1) a)) with ({a});
    apply member_set_repeat;
    lia;
    auto_set;
    apply included_fold;
    intros;
    apply projection_in_intro_l in H2;
    destruct H2 with (ex_ind ? ?) to (x x_property);
    destruct x_property with (and_ind ? ?) to (x_property_l x_property_r);
    apply set_from_func_unfold in x_property_l;
    destruct x_property_l with (and_ind ? ?) to (x_property_l_l x_property_l_r);
    destruct x;
    lia;
    replace #1 (head d (x0 :: l)) with (x0) in x_property_r;
    auto_list;
    replace #1 (member_set (x0 :: l)) with ({x0} ∪ member_set ( l)) in x_property_l_l;
    apply member_set_cons_union;
    auto_set;
    auto_list;
    apply pow_pos;
    lia;
    assumption;
    lia;

Qed;

Todo count_of_binary_lists: ∀ T: U, ∀ a b: T, ~ a = b -> ∀ n, 0 ≤ n -> |{ l: list T | member_set l ⊆ {a, b} ∧ |l| = n }| = 2 ^ n;

Axiom factorial: ℤ -> ℤ;
Axiom factorial_0: factorial 0 = 1;
Axiom factorial_n: ∀ n: ℤ, n > 0 -> factorial n = n * factorial (n - 1);
Todo factorial_gt_0: ∀ n: ℤ, 0 ≤ n -> 0 < factorial n; 

Theorem count_permution: ∀ T: U, ∀ S: set T, ∀ n: ℤ, 0 ≤ n -> |S| = n -> |{ l: list T | member_set l ⊆ S ∧ |l| = n ∧ (unique_elements l) }| = factorial n;
Proof;
    intros;
    revert H0;
    revert S;
    revert H;
    revert n;
    apply z_induction_simple;
    Switch 1;
    intros;
    apply empty_len_unique in H0;
    rewrite H0;
    replace #1 ({ l: list T | member_set l ⊆ {} ∧ |l| = 0 ∧ unique_elements l }) with ({[]});
    apply set_equality;
    apply included_fold;
    intros;
    apply singleton_unfold in H;
    apply eq_sym in H;
    rewrite H;
    apply set_from_func_fold;
    apply and_intro;
    apply and_intro;
    apply unique_elements_nil;
    lia;
    apply member_set_nil_included;
    apply included_fold;
    intros;
    apply set_from_func_unfold in H;
    destruct H with (and_ind ? ?) to (H_l H_r);
    destruct H_r with (and_ind ? ?) to (H_r_l H_r_r);
    apply nil_unique in H_r_l;
    auto_set;
    replace #1 (factorial 0) with (1);
    apply factorial_0;
    apply singleton_len;
    intros;
    replace #1 ({ l: list T | member_set l ⊆ S ∧ |l| = n + 1 ∧ unique_elements l }) with ({ l: list T | ∃ a: T, ∃ y: list T, l = a :: y ∧ a ∈ S ∧ (~ a in y ∧ member_set y ⊆ S ∧ |y| = n ∧ unique_elements y)  });
    Switch 1;
    replace #1 (factorial (n + 1)) with (( n + 1) * factorial (n));
    add_from_lib factorial_n;
    add_hyp factorial_n_ex := (factorial_n (n + 1));
    lia;
    apply (⁨rule_of_bijection_product2 ?0 ?2 ?4 ?6 ?8 ?10 (λ a: T,   λ y: list T, a :: y) ?14 (λ a: T,   λ y: list T,     ~ a in y ∧ member_set y ⊆ S ∧ |y| = n ∧ unique_elements y) ?18 ?20 ?22⁩);
    intros;
    z3;
    intros;
    replace #1 ({ y: list T | ~ a in y ∧ member_set y ⊆ S ∧ |y| = n ∧ unique_elements y }) with ({ y: list T | member_set y ⊆ (S ∖ {a}) ∧ |y| = n ∧ unique_elements y });
    apply set_from_func_eq;
    intros;
    add_hyp ( |x| = n ∧ unique_elements x -> (~ a in x ∧ member_set x ⊆ S  ↔ member_set x ⊆ S ∖ {a}));
    intros;
    apply and_intro;
    intros;
    apply and_intro;
    z3;
    intros;
    add_hyp (a ∈ member_set x);
    apply inlist_member_set;
    assumption;
    z3;
    intros;
    add_hyp (~ a ∈ member_set x);
    intros;
    apply member_set_inlist in H4;
    assumption;
    auto_set;
    assumption;
    apply H0;
    apply subset_len;
    assumption;
    assumption;
    assumption;
    replace #1 ({ x: T | x ∈ S }) with (S);
    apply set_equality;
    apply included_fold;
    apply set_from_func_fold;
    apply included_fold;
    intros;
    apply set_from_func_unfold in H1;
    assumption;
    assumption;
    add_from_lib factorial_gt_0;
    add_hyp factorial_gt_0_ex := (factorial_gt_0 (n));
    lia;
    apply set_equality;
    apply included_fold;
    intros;
    apply set_from_func_unfold in H1;
    apply set_from_func_fold;
    destruct H1 with (ex_ind ? ?) to (a0 a0_property);
    destruct a0_property with (ex_ind ? ?) to (y y_property);
    destruct y_property with (and_ind ? ?) to (y_property_l y_property_r);
    replace #1 (member_set a) with ({a0} ∪ member_set y);
    rewrite y_property_l;
    apply member_set_cons_union;
    rewrite y_property_l;
    apply and_intro;
    apply and_intro;
    apply unique_elements_cons_fold;
    assumption;
    lia;
    auto_set;
    apply included_fold;
    intros;
    apply set_from_func_fold;
    apply set_from_func_unfold in H1;
    add_from_lib cons_nil_case;
    add_hyp cons_nil_case_ex := (cons_nil_case (T));
    add_hyp cons_nil_case_ex_ex := (cons_nil_case_ex (a));
    destruct cons_nil_case_ex_ex with (or_ind ? ?);
    destruct cons_nil_case_ex_ex with (ex_ind ? ?) to (y y_property);
    destruct y_property with (ex_ind ? ?) to (a0 a0_property);
    apply (ex_intro ? ? (a0));
    apply (ex_intro ? ? (y));
    apply and_intro;
    apply and_intro;
    apply and_intro;
    apply and_intro;
    apply and_intro;
    destruct H1 with (and_ind ? ?) to (H1_l H1_r);
    destruct H1_r with (and_ind ? ?) to (H1_r_l H1_r_r);
    revert H1_r_r;
    revert H1_l;
    revert H1_r_l;
    rewrite a0_property;
    intros;
    apply unique_elements_cons_unfold in H1_r_r ;
    assumption;
    z3;
    replace #1 (member_set a) with ({a0} ∪ member_set y) in H1;
    rewrite a0_property ;
    apply member_set_cons_union;
    auto_set;
    destruct H1 with (and_ind ? ?) to (H1_l H1_r) ;
    destruct H1_r with (and_ind ? ?) to (H1_r_l H1_r_r) ;
    replace #1 (a) with (a0 ::y) in H1_r_r;
    assumption;
    apply unique_elements_cons_unfold in H1_r_r ;
    assumption;
    replace #1 (member_set a) with ({a0} ∪ member_set y) in H1;
    rewrite a0_property ;
    apply member_set_cons_union;
    auto_set;
    assumption;
    z3;
Qed;

Todo P_n_r: ∀ n: ℤ, ∀ r: ℤ, 0 ≤ r ∧ r ≤ n  -> ∀ T: U, ∀ S: set T, |S|  = n -> 
    |{l | member_set l ⊆ S ∧ |l| = r ∧ unique_elements l}| = multi  {x| n - r < x ∧ x ≤ n};

Theorem valid_paren_convert: ∀ l, ∀ n, |l| = 2 * n ->  valid_paren l <-> cnt '(' l = n ∧ cnt ')' l = n ∧ (∀ i, 0 < i -> i ≤ |l| -> cnt ')' (firstn l i) ≤ cnt '(' (firstn l i));
Proof;
    apply list_induction_len;
    intros;
    destruct b;
    apply and_intro;
    intros;
    apply valid_paren_empty;
    intros;
    apply and_intro;
    apply and_intro;
    intros;
    lia;
    lia;
    lia;
    apply and_intro;
    intros;
    destruct H1 with (and_ind ? ?) to (H1_l H1_r);
    destruct H1_r with (and_ind ? ?) to (H1_r_l H1_r_r);
    add_hyp (member_set (x::l) ⊆ {'(', ')'});
    apply member_set_is_two_element_l;
    lia;
    add_hyp (x = '(');
    apply NNPP;
    intros;
    add_hyp (x = ')');
    apply included_unfold in H1;
    add_hyp H1_ex := (H1 (x));
    Seq (add_hyp (⁨x ∈ member_set (x :: l)⁩)) (remove_hyp H1_ex) (Switch 1) (add_hyp H1_ex_o := (H1_ex H3)) (remove_hyp H3) (remove_hyp H1_ex);
    auto_set;
    apply member_set_cons;
    add_hyp H1_r_r_ex := (H1_r_r (1));
    Seq (add_hyp (⁨0 < 1⁩)) (remove_hyp H1_r_r_ex) (Switch 1) (add_hyp H1_r_r_ex_o := (H1_r_r_ex H4)) (remove_hyp H4) (remove_hyp H1_r_r_ex);
    Seq (add_hyp (⁨1 ≤ |x :: l|⁩)) (remove_hyp H1_r_r_ex_o) (Switch 1) (add_hyp H1_r_r_ex_o_o := (H1_r_r_ex_o H4)) (remove_hyp H4) (remove_hyp H1_r_r_ex_o);
    replace #1 ((firstn (x :: l) 1)) with ([x]) in H1_r_r_ex_o_o;
    apply firstn_cons_1;
    destruct H1_r_r_ex_o_o with (or_ind ? ?);
    replace #1 ((firstn (x :: l) 1)) with ([x]) in H1_r_r_ex_o_o;
    apply firstn_cons_1;
    revert H1_r_r_ex_o_o;
    rewrite H3;
    lia;
    replace #1 ((firstn (x :: l) 1)) with ([x]) in H1_r_r_ex_o_o;
    apply firstn_cons_1;
    revert H1_r_r_ex_o_o;
    rewrite H3;
    lia;
    lia;
    lia;
    add_hyp (∃ i, i > -1 ∧ i ≤ |l| ∧ (cnt ')' (firstn l i) = cnt '(' (firstn l i) + 1));
    apply (ex_intro ? ? (|l|));
    apply and_intro;
    replace #1 ((firstn l (|l|))) with (l);
    apply firstn_len;
    replace #1 ((firstn l (|l|))) with (l);
    apply firstn_len;
    revert H1_l;
    revert H1_r_l;
    revert H1_r_r;
    rewrite H2;
    lia;
    lia;
    apply ex_min in H3;
    destruct H3 with (ex_ind ? ?) to (i i_property);
    destruct i_property with (and_ind ? ?) to (i_property_l i_property_r);
    destruct i_property_r with (and_ind ? ?) to (i_property_r_l i_property_r_r);
    add_from_lib split_index;
    add_hyp split_index_ex := (split_index (char));
    add_hyp split_index_ex_ex := (split_index_ex (l));
    add_hyp split_index_ex_ex_ex := (split_index_ex_ex (i));
    Seq (add_hyp (⁨0 < i⁩)) (remove_hyp split_index_ex_ex_ex) (Switch 1) (add_hyp split_index_ex_ex_ex_o := (split_index_ex_ex_ex H3)) (remove_hyp H3) (remove_hyp split_index_ex_ex_ex);
    remove_hyp split_index_ex_ex;
    remove_hyp split_index_ex;
    Seq (add_hyp (⁨i ≤ |l|⁩)) (remove_hyp split_index_ex_ex_ex_o) (Switch 1) (add_hyp split_index_ex_ex_ex_o_o := (split_index_ex_ex_ex_o H3)) (remove_hyp H3) (remove_hyp split_index_ex_ex_ex_o);
    destruct split_index_ex_ex_ex_o_o with (ex_ind ? ?) to (a a_property);
    destruct a_property with (ex_ind ? ?) to (b b_property);
    destruct b_property with (ex_ind ? ?) to (y y_property);
    destruct y_property with (and_ind ? ?) to (y_property_l y_property_r);
    destruct y_property_r with (and_ind ? ?) to (y_property_r_l y_property_r_r);
    add_hyp (y = ')');
    revert H1_r_r;
    revert H1;
    revert i_property_r_l;
    revert i_property_r_r;
    rewrite y_property_l;
    intros;
    Switch 2;
    add_hyp i_property_r_r_ex := (i_property_r_r (|l|));
    Seq (add_hyp (⁨- 1 < |l|⁩)) (remove_hyp i_property_r_r_ex) (Switch 1) (add_hyp i_property_r_r_ex_o := (i_property_r_r_ex H3)) (remove_hyp H3) (remove_hyp i_property_r_r_ex);
    assumption;
    lia;
    Switch 1;
    apply NNPP;
    intros;
    add_hyp (y = '(');
    apply included_unfold in H1;
    add_hyp H1_ex := (H1 (y));
    Seq (add_hyp (⁨y ∈ member_set (x :: (a + y :: b))⁩)) (remove_hyp H1_ex) (Switch 1) (add_hyp H1_ex_o := (H1_ex H4)) (remove_hyp H4) (remove_hyp H1_ex);
    auto_set;
    replace #1 (member_set (x :: (a + y :: b))) with ({x} ∪ member_set ((a + y :: b)));
    apply member_set_cons_union;
    replace #1 (member_set (a + y :: b)) with (member_set a ∪ member_set (y :: b));
    apply member_set_append;
    replace #1 (member_set (y :: b)) with ({y} ∪ member_set (b));
    apply member_set_cons_union;
    auto_set;
    add_hyp (∃ j, j > -1 ∧ j < i ∧ (cnt '(' (firstn a j) + 1 ≤ cnt ')' (firstn a j)) );
    apply (ex_intro ? ? (i - 1));
    apply and_intro;
    apply and_intro;
    destruct i_property_r_l with (and_ind ? ?) to (i_property_r_l_l i_property_r_l_r);
    replace #1 ((firstn (a + y :: b) i)) with (a + [y]) in i_property_r_l_r;
    replace #1 (firstn (a + y :: b) i) with (a + firstn (y :: b) 1);
    replace #1 (i) with ((|a| + 1));
    lia;
    apply firstn_append_r;
    lia;
    replace #1 (firstn (y :: b) 1) with ([y]);
    apply firstn_cons_1;
    auto_list;
    replace #1 ((firstn (a + y :: b) i)) with ((a + [y])) in i_property_r_l_r;
    replace #1 (firstn (a + y :: b) i) with (a + firstn (y :: b) 1);
    replace #1 (i) with ((|a| + 1));
    lia;
    apply firstn_append_r;
    lia;
    replace #1 (firstn (y :: b) 1) with ([y]);
    apply firstn_cons_1;
    auto_list;
    revert i_property_r_l_r;
    rewrite H4;
    intros;
    replace #1 ((firstn a (i - 1))) with (a);
    replace #1 ((i - 1)) with (|a|);
    auto_set;
    apply firstn_len;
    replace #1 ((firstn a (i - 1))) with (a);
    replace #1 ((i - 1)) with (|a|);
    auto_set;
    apply firstn_len;
    lia;
    lia;
    lia;
    apply ex_min in H5;
    destruct H5 with (ex_ind ? ?) to (j j_property);
    destruct j_property with (and_ind ? ?) to (j_property_l j_property_r);
    destruct j_property_r with (and_ind ? ?) to (j_property_r_l j_property_r_r);
    add_hyp i_property_r_r_ex := (i_property_r_r (j));
    Seq (add_hyp (⁨- 1 < j⁩)) (remove_hyp i_property_r_r_ex) (Switch 1) (add_hyp i_property_r_r_ex_o := (i_property_r_r_ex H5)) (remove_hyp H5) (remove_hyp i_property_r_r_ex);
    add_hyp (( j ≤ |a + y :: b| ∧ cnt ')' (firstn (a + y :: b) j) = cnt '(' (firstn (a + y :: b) j) + 1));
    apply and_intro;
    add_hyp (~ cnt '(' (firstn a j) + 1 < cnt ')' (firstn a j));
    intros;
    add_hyp j_property_r_r_ex := (j_property_r_r (j - 1));
    Seq (add_hyp (⁨- 1 < j - 1⁩)) (remove_hyp j_property_r_r_ex) (Switch 1) (add_hyp j_property_r_r_ex_o := (j_property_r_r_ex H6)) (remove_hyp H6) (remove_hyp j_property_r_r_ex);
    Seq (add_hyp (⁨j - 1 < i ∧ cnt '(' (firstn a (j - 1)) + 1 ≤ cnt ')' (firstn a (j - 1))⁩)) (remove_hyp j_property_r_r_ex_o) (Switch 1) (add_hyp j_property_r_r_ex_o_o := (j_property_r_r_ex_o H6)) (remove_hyp H6) (remove_hyp j_property_r_r_ex_o);
    lia;
    apply and_intro;
    add_from_lib cnt_of_firstn_dis_range;
    add_hyp cnt_of_firstn_dis_range_ex := (cnt_of_firstn_dis_range (char));
    add_hyp cnt_of_firstn_dis_range_ex_ex := (cnt_of_firstn_dis_range_ex (a));
    add_hyp cnt_of_firstn_dis_range_ex_ex_ex := (cnt_of_firstn_dis_range_ex_ex (j));
    add_hyp cnt_of_firstn_dis_range_ex_ex_ex_ex := (cnt_of_firstn_dis_range_ex_ex_ex ('('));
    add_hyp cnt_of_firstn_dis_range_ex_ex_ex_ex0 := (cnt_of_firstn_dis_range_ex_ex_ex (')'));
    lia;
    lia;
    add_hyp (~ j = 0);
    intros;
    replace #1 ((firstn a j)) with ([]) in H5;
    apply firstn_le_0;
    assumption;
    replace #1 ((firstn a j)) with ([]) in H5;
    apply firstn_le_0;
    assumption;
    lia;
    lia;
    destruct j_property_r_l with (and_ind ? ?) to (j_property_r_l_l j_property_r_l_r);
    replace #1 (firstn (a + y :: b) j) with (firstn a j);
    apply firstn_append_l;
    lia;
    replace #1 ((firstn (a + y :: b) j)) with ((firstn (a) j));
    apply firstn_append_l;
    lia;
    lia;
    lia;
    lia;
    assumption;
    rewrite y_property_l;
    rewrite H3;
    rewrite H2;
    revert y_property_l;
    rewrite H3;
    intros;
    destruct i_property_r_l with (and_ind ? ?) to (i_property_r_l_l i_property_r_l_r);
    replace #1 ((firstn l i)) with (a + ")") in i_property_r_l_r;
    rewrite y_property_l;
    replace #1 (a + ')' :: b) with (a + ")" + b);
    auto_list;
    replace #1 (i) with (|a+")"|);
    lia;
    replace #3 (a + ")") with (firstn (a + ")") (|a+")"|));
    apply eq_sym;
    apply firstn_len;
    apply firstn_append_l;
    auto_list;
    add_hyp (cnt ')' a = cnt '(' a);
    replace #1 ((firstn l i)) with ((a + ")")) in i_property_r_l_r;
    rewrite y_property_l;
    replace #1 (a + ')' :: b) with (a + ")" + b);
    auto_list;
    replace #1 (i) with (|a+")"|);
    lia;
    replace #3 (a + ")") with (firstn (a + ")") (|a+")"|));
    apply eq_sym;
    apply firstn_len;
    apply firstn_append_l;
    auto_list;
    lia;
    add_hyp (|a| = cnt '(' a + cnt ')' a);
    apply member_set_is_two_element_r;
    revert H1;
    rewrite y_property_l;
    intros;
    replace #1 (member_set (x :: (a + ')' :: b))) with ({x} ∪ member_set ( (a + ')' :: b))) in H1;
    apply member_set_cons_union;
    replace #1 (member_set (a + ')' :: b)) with (member_set (a) ∪ member_set ( ')' :: b)) in H1;
    apply member_set_append;
    apply included_fold;
    intros;
    apply included_unfold in H1;
    add_hyp H1_ex := (H1 (a0));
    auto_set;
    add_hyp (|b| = cnt '(' b + cnt ')' b);
    apply member_set_is_two_element_r;
    revert H1;
    rewrite y_property_l;
    intros;
    replace #1 (member_set (x :: (a + ')' :: b))) with ({x} ∪ member_set ( (a + ')' :: b))) in H1;
    apply member_set_cons_union;
    replace #1 (member_set (a + ')' :: b)) with (member_set (a) ∪ member_set( ')' :: b)) in H1;
    apply member_set_append;
    apply included_fold;
    apply included_unfold in H1;
    intros;
    add_hyp H1_ex := (H1 (a0));
    replace #1 (member_set (')' :: b)) with ({')'} ∪ member_set ( b)) in H1_ex;
    apply member_set_cons_union;
    auto_set;
    apply valid_paren_fold;
    apply (ex_intro ? ? (a));
    apply (ex_intro ? ? (b));
    apply and_intro;
    apply and_intro;
    auto_list;
    add_hyp H_ex := (H (b));
    Seq (add_hyp (⁨|b| < |x :: l|⁩)) (remove_hyp H_ex) (Switch 1) (add_hyp H_ex_o := (H_ex H7)) (remove_hyp H7) (remove_hyp H_ex);
    add_hyp H_ex_o_ex := (H_ex_o (cnt '(' b));
    Seq (add_hyp (⁨|b| = 2 * cnt '(' b⁩)) (remove_hyp H_ex_o_ex) (Switch 1) (add_hyp H_ex_o_ex_o := (H_ex_o_ex H7)) (remove_hyp H7) (remove_hyp H_ex_o_ex);
    apply iff_imp_l in H_ex_o_ex_o;
    apply H_ex_o_ex_o;
    remove_hyp H_ex_o_ex_o;
    remove_hyp H_ex_o;
    remove_hyp H;
    apply and_intro;
    apply and_intro;
    intros;
    revert H1_r_r;
    rewrite H2;
    rewrite y_property_l;
    intros;
    replace #2 (('(' :: (a + ')' :: b))) with (('(' :: a + ")") + b) in H1_r_r;
    auto_list;
    add_hyp H1_r_r_ex := (H1_r_r (|'(' :: a + ")"| + i0));
    Seq (add_hyp (⁨0 < |'(' :: a + ")"| + i0⁩)) (remove_hyp H1_r_r_ex) (Switch 1) (add_hyp H1_r_r_ex_o := (H1_r_r_ex H8)) (remove_hyp H8) (remove_hyp H1_r_r_ex);
    Seq (add_hyp (⁨|'(' :: a + ")"| + i0 ≤ |'(' :: (a + ')' :: b)|⁩)) (remove_hyp H1_r_r_ex_o) (Switch 1) (add_hyp H1_r_r_ex_o_o := (H1_r_r_ex_o H8)) (remove_hyp H8) (remove_hyp H1_r_r_ex_o);
    replace #1 (('(' :: (a + ')' :: b))) with ('(' :: a + ")" + b) in H1_r_r_ex_o_o;
    auto_list;
    replace #1 ((firstn ('(' :: a + ")" + b) (|'(' :: a + ")"| + i0))) with ('(' :: a + ")" + (firstn (b) (i0))) in H1_r_r_ex_o_o;
    apply firstn_append_r;
    assumption;
    replace #1 ((firstn ('(' :: a + ")" + b) (|'(' :: a + ")"| + i0))) with ('(' :: a + ")" + (firstn (b) (i0))) in H1_r_r_ex_o_o;
    apply firstn_append_r;
    assumption;
    lia;
    lia;
    lia;
    revert H1_l;
    revert H1_r_l;
    rewrite H2;
    rewrite y_property_l;
    lia;
    auto_list;
    add_hyp (cnt '(' b = cnt ')' b);
    revert H1_l;
    revert H1_r_l;
    rewrite H2;
    rewrite y_property_l;
    lia;
    lia;
    lia;
    add_hyp H_ex := (H (a));
    Seq (add_hyp (⁨|a| < |x :: l|⁩)) (remove_hyp H_ex) (Switch 1) (add_hyp H_ex_o := (H_ex H7)) (remove_hyp H7) (remove_hyp H_ex);
    add_hyp H_ex_o_ex := (H_ex_o (cnt '(' a));
    Seq (add_hyp (⁨|a| = 2 * cnt '(' a⁩)) (remove_hyp H_ex_o_ex) (Switch 1) (add_hyp H_ex_o_ex_o := (H_ex_o_ex H7)) (remove_hyp H7) (remove_hyp H_ex_o_ex);
    apply iff_imp_l in H_ex_o_ex_o;
    apply H_ex_o_ex_o;
    apply and_intro;
    apply and_intro;
    intros;
    remove_hyp H;
    remove_hyp H_ex_o;
    remove_hyp H_ex_o_ex_o;
    add_hyp H1_r_r_ex := (H1_r_r (i0 + 1));
    Seq (add_hyp (⁨0 < i0 + 1⁩)) (remove_hyp H1_r_r_ex) (Switch 1) (add_hyp H1_r_r_ex_o := (H1_r_r_ex H)) (remove_hyp H) (remove_hyp H1_r_r_ex);
    Seq (add_hyp (⁨i0 + 1 ≤ |x :: l|⁩)) (remove_hyp H1_r_r_ex_o) (Switch 1) (add_hyp H1_r_r_ex_o_o := (H1_r_r_ex_o H)) (remove_hyp H) (remove_hyp H1_r_r_ex_o);
    replace #1 (firstn (x :: l) (i0 + 1)) with ('('::firstn (l) (i0)) in H1_r_r_ex_o_o;
    rewrite H2;
    apply firstn_cons;
    assumption;
    replace #1 (firstn (x :: l) (i0 + 1)) with ('('::firstn (l) (i0)) in H1_r_r_ex_o_o;
    rewrite H2;
    apply firstn_cons;
    assumption;
    revert H1_r_r_ex_o_o;
    rewrite y_property_l;
    intros;
    replace #1 (firstn (a + ')' :: b) i0) with (firstn (a) i0) in H1_r_r_ex_o_o;
    apply firstn_append_l;
    assumption;
    replace #1 (firstn (a + ')' :: b) i0) with (firstn (a ) i0) in H1_r_r_ex_o_o;
    apply firstn_append_l;
    assumption;
    add_hyp (~ cnt ')' (firstn a i0) = 1 + cnt '(' (firstn a i0));
    intros;
    add_hyp i_property_r_r_ex := (i_property_r_r (i0));
    Seq (add_hyp (⁨- 1 < i0⁩)) (remove_hyp i_property_r_r_ex) (Switch 1) (add_hyp i_property_r_r_ex_o := (i_property_r_r_ex H9)) (remove_hyp H9) (remove_hyp i_property_r_r_ex);
    Seq (add_hyp (⁨i0 ≤ |l| ∧ cnt ')' (firstn l i0) = cnt '(' (firstn l i0) + 1⁩)) (remove_hyp i_property_r_r_ex_o) (Switch 1) (add_hyp i_property_r_r_ex_o_o := (i_property_r_r_ex_o H9)) (remove_hyp H9) (remove_hyp i_property_r_r_ex_o);
    lia;
    apply and_intro;
    rewrite y_property_l;
    replace #1 (firstn (a + ')' :: b) i0) with (firstn (a) i0);
    apply firstn_append_l;
    assumption;
    replace #1 (firstn (a + ')' :: b) i0) with (firstn (a ) i0);
    apply firstn_append_l;
    assumption;
    lia;
    lia;
    lia;
    lia;
    lia;
    lia;
    assumption;
    auto_list;
    lia;
    lia;
    add_hyp (~ i = 0);
    intros;
    destruct i_property_r_l with (and_ind ? ?) to (i_property_r_l_l i_property_r_l_r);
    replace #1 ((firstn l i)) with ("") in i_property_r_l_r;
    rewrite H3;
    apply firstn_le_0;
    auto_list;
    replace #1 ((firstn l i)) with ("") in i_property_r_l_r;
    rewrite H3;
    apply firstn_le_0;
    auto_list;
    lia;
    lia;
    intros;
    apply and_intro;
    apply and_intro;
    intros;
    apply valid_paren_unfold in H1;
    destruct H1 with (or_ind ? ?);
    destruct H1 with (ex_ind ? ?) to (a a_property);
    destruct a_property with (ex_ind ? ?) to (b b_property);
    destruct b_property with (and_ind ? ?) to (b_property_l b_property_r);
    destruct b_property_r with (and_ind ? ?) to (b_property_r_l b_property_r_r);
    replace #1 ("(" + a + ")" + b) with ('(' ::( a + ")" + b)) in b_property_r_r;
    auto_list;
    apply cons_eq in b_property_r_r;
    destruct b_property_r_r with (and_ind ? ?) to (b_property_r_r_l b_property_r_r_r);
    revert H3;
    rewrite b_property_r_r_l;
    rewrite b_property_r_r_r;
    intros;
    add_hyp (∀ j, 0 ≤ j -> j ≤ |a| -> cnt ')' (firstn a j) ≤ cnt '(' (firstn a j) );
    intros;
    add_hyp (j = 0 ∨ 0 < j);
    lia;
    destruct H5 with (or_ind ? ?);
    add_hyp H_ex := (H (a));
    Seq (add_hyp (⁨|a| < |x :: l|⁩)) (remove_hyp H_ex) (Switch 1) (add_hyp H_ex_o := (H_ex H6)) (remove_hyp H6) (remove_hyp H_ex);
    add_hyp (2 | |a|);
    apply valid_paren_len_even;
    assumption;
    apply divide_unfold in H6;
    destruct H6 with (ex_ind ? ?) to (k k_property);
    add_hyp H_ex_o_ex := (H_ex_o (k));
    Seq (add_hyp (⁨|a| = 2 * k⁩)) (remove_hyp H_ex_o_ex) (Switch 1) (add_hyp H_ex_o_ex_o := (H_ex_o_ex H6)) (remove_hyp H6) (remove_hyp H_ex_o_ex);
    apply iff_imp_r in H_ex_o_ex_o;
    add_hyp (cnt '(' a = k ∧ cnt ')' a = k ∧ ∀ i0: ℤ, 0 < i0 → i0 ≤ |a| → cnt ')' (firstn a i0) ≤ cnt '(' (firstn a i0));
    assumption;
    remove_hyp H_ex_o_ex_o;
    destruct H6 with (and_ind ? ?) to (H6_l H6_r);
    destruct H6_r with (and_ind ? ?) to (H6_r_l H6_r_r);
    add_hyp H6_r_r_ex := (H6_r_r (j));
    assumption;
    auto_set;
    rewrite b_property_r_r_r;
    lia;
    rewrite H5;
    replace #1 (firstn a 0) with ([]);
    apply firstn_le_0;
    auto_list;
    replace #1 ((firstn a 0)) with ("");
    apply firstn_le_0;
    auto_list;
    lia;
    add_hyp (⁨i ≤ |a| + 1 + 1 ∨ i  > |a| + 1 + 1⁩);
    lia;
    destruct H4 with (or_ind ? ?);
    replace #1 (('(' :: (a + ")" + b))) with (('(' :: (a + ")") + b));
    auto_list;
    replace #1 (('(' :: (a + ")" + b))) with (('(' :: (a + ")") + b));
    auto_list;
    replace #1 ((firstn ('(' :: (a + ")") + b) i)) with ('(' :: (a + ")") + firstn (b) (i - |'(' :: (a + ")")| ));
    replace #1 (i) with (|'(' :: (a + ")")| + (i - | '(' :: (a + ")")|));
    lia;
    apply firstn_append_r;
    lia;
    replace #1 ((firstn ('(' :: (a + ")") + b) i)) with (('(' :: (a + ")") + firstn b (i - |'(' :: (a + ")")|)));
    replace #1 (i) with (|'(' :: (a + ")")| + (i - | '(' :: (a + ")")|));
    lia;
    apply firstn_append_r;
    lia;
    add_hyp (cnt ')' (firstn b (i - |'(' :: (a + ")")|)) ≤ cnt '(' (firstn b (i - |'(' :: (a + ")")|)));
    add_hyp H_ex := (H (b));
    Seq (add_hyp (⁨|b| < |x :: l|⁩)) (remove_hyp H_ex) (Switch 1) (add_hyp H_ex_o := (H_ex H5)) (remove_hyp H5) (remove_hyp H_ex);
    add_hyp (2 | |b|);
    apply valid_paren_len_even;
    assumption;
    apply divide_unfold in H5;
    destruct H5 with (ex_ind ? ?) to (k k_property);
    add_hyp H_ex_o_ex := (H_ex_o (k));
    Seq (add_hyp (⁨|b| = 2 * k⁩)) (remove_hyp H_ex_o_ex) (Switch 1) (add_hyp H_ex_o_ex_o := (H_ex_o_ex H5)) (remove_hyp H5) (remove_hyp H_ex_o_ex);
    apply iff_imp_r in H_ex_o_ex_o;
    add_hyp (cnt '(' b = k ∧ cnt ')' b = k ∧ ∀ i0: ℤ, 0 < i0 → i0 ≤ |b| → cnt ')' (firstn b i0) ≤ cnt '(' (firstn b i0));
    assumption;
    destruct H5 with (and_ind ? ?) to (H5_l H5_r);
    destruct H5_r with (and_ind ? ?) to (H5_r_l H5_r_r);
    add_hyp H5_r_r_ex := (H5_r_r ((i - |'(' :: (a + ")")|)));
    lia;
    auto_set;
    rewrite b_property_r_r_r;
    lia;
    add_hyp H1_ex := (H1 (|a|));
    replace #1 ((firstn a (|a|))) with (a) in H1_ex;
    apply firstn_len;
    replace #1 ((firstn a (|a|))) with (a) in H1_ex;
    apply firstn_len;
    lia;
    replace #1 ((firstn ('(' :: (a + ")" + b)) i)) with ((firstn ('(' :: (a + ")")) i));
    replace #1 ('(' :: (a + ")" + b)) with ('(' :: (a + ")") + b);
    auto_list;
    apply firstn_append_l;
    lia;
    replace #1 ((firstn ('(' :: (a + ")" + b)) i)) with ((firstn ('(' :: (a + ")")) i));
    replace #1 ('(' :: (a + ")" + b)) with ('(' :: (a + ")") + b);
    auto_list;
    apply firstn_append_l;
    lia;
    add_hyp (i = |a| + 2 ∨ i ≤ |a| + 1);
    lia;
    destruct H5 with (or_ind ? ?);
    add_hyp H1_ex := (H1 (i - 1));
    replace #1 (firstn ('(' :: (a + ")")) i) with ('(' :: firstn a (i - 1));
    replace #1 (firstn a (i - 1)) with (firstn (a + ")") (i - 1));
    apply eq_sym;
    apply firstn_append_l;
    lia;
    replace #1 (i) with (i - 1 + 1);
    lia;
    apply firstn_cons;
    lia;
    replace #1 (firstn ('(' :: (a + ")")) i) with (('(' :: firstn a (i - 1)));
    replace #1 (firstn a (i - 1)) with (firstn (a + ")") (i - 1));
    apply eq_sym;
    apply firstn_append_l;
    lia;
    replace #1 (i) with (i - 1 + 1);
    lia;
    apply firstn_cons;
    lia;
    lia;
    replace #1 (firstn ('(' :: (a + ")")) i) with ('(' :: (firstn ( (a)) (i - 2) + ")"));
    replace #2 (")") with (firstn ")" 1);
    apply eq_sym;
    apply firstn_cons_1;
    replace #1 ((firstn a (i - 2) + firstn ")" 1)) with (firstn (a + ")") (|a| + 1));
    replace #1 ((i - 2)) with (|a|);
    lia;
    apply eq_sym;
    replace #1 (firstn a (|a|)) with (a);
    apply firstn_len;
    apply firstn_append_r;
    lia;
    replace #1 (i) with (|a| + 1 + 1);
    lia;
    apply firstn_cons;
    lia;
    replace #1 ((firstn ('(' :: (a + ")")) i)) with ('(' :: (firstn a (i - 2) + ")"));
    replace #2 (")") with (firstn ")" 1);
    apply eq_sym;
    apply firstn_cons_1;
    replace #1 ((firstn a (i - 2) + firstn ")" 1)) with (firstn (a + ")") (|a| + 1));
    replace #1 ((i - 2)) with (|a|);
    lia;
    apply eq_sym;
    replace #1 (firstn a (|a|)) with (a);
    apply firstn_len;
    apply firstn_append_r;
    lia;
    replace #1 (i) with (|a| + 1 + 1);
    lia;
    apply firstn_cons;
    lia;
    replace #1 (firstn a (i - 2)) with (a);
    replace #1 ((i - 2)) with (|a|);
    lia;
    apply firstn_len;
    replace #1 (firstn a (i - 2)) with (a);
    replace #1 ((i - 2)) with (|a|);
    lia;
    apply firstn_len;
    add_hyp H1_ex := (H1 (|a|));
    replace #1 ((firstn a (|a|))) with (a) in H1_ex;
    apply firstn_len;
    replace #1 ((firstn a (|a|))) with (a) in H1_ex;
    apply firstn_len;
    lia;
    auto_list;
    apply valid_paren_cnt_right;
    auto_set;
    assumption;
    apply valid_paren_cnt_left;
    auto_set;
    assumption;
Qed;

Theorem valid_parens_count: ∀ n, n > 0 -> | { l | |l| = 2 * n ∧ valid_paren l } | = cm (2 * n) (n) - cm (2 * n) (n - 1);
Proof;
    intros n H_gt_0;
    replace #1 ({ l: list char | |l| = 2 * n ∧ valid_paren l }) with ({ l: list char | |l| = 2 * n ∧ cnt '(' l = n ∧ cnt ')' l = n ∧ ∀ i: ℤ, 0 < i → i ≤ |l| → cnt ')' (firstn l i) ≤ cnt '(' (firstn l i) });
    apply set_from_func_eq;
    intros;
    add_hyp (|x| = 2 * n ->  valid_paren x ↔  cnt '(' x = n ∧ cnt ')' x = n ∧ ∀ i: ℤ, 0 < i → i ≤ |x| → cnt ')' (firstn x i) ≤ cnt '(' (firstn x i));
    intros;
    apply valid_paren_convert;
    assumption;
    assumption;
    apply (⁨rule_of_bijectionR ?0 (list char) (λ l: (list char),   map (λ c: char, if_f (c = '(') 'r' 'u') l) ?4 ?6 ?8 ?10 ?12⁩);
    replace #1 (projection { l: list char | |l| = 2 * n ∧ cnt '(' l = n ∧ cnt ')' l = n ∧ ∀ i: ℤ, 0 < i → i ≤ |l| → cnt ')' (firstn l i) ≤ cnt '(' (firstn l i) } (map (λ c: char, if_f (c = '(') 'r' 'u'))) with ({ l: list char | |l| = 2 * n ∧ cnt 'r' l = n ∧ cnt 'u' l = n ∧ ∀ i: ℤ, 0 < i → i ≤ |l| → cnt 'u' (firstn l i) ≤ cnt 'r' (firstn l i) });
    apply set_equality;
    apply included_fold;
    intros;
    apply projection_in_intro_r;
    apply set_from_func_unfold in H;
    apply (ex_intro ? ? (map (λ c: char, if_f (c = 'r') '(' ')') a));
    destruct H with (and_ind ? ?) to (H_l H_r);
    destruct H_r with (and_ind ? ?) to (H_r_l H_r_r);
    destruct H_r_r with (and_ind ? ?) to (H_r_r_l H_r_r_r);
    apply and_intro;
    replace #1 (map (λ c: char, if_f (c = '(') 'r' 'u') (map (λ c: char, if_f (c = 'r') '(' ')') a)) with (map (λ x, (λ c: char, if_f (c = '(') 'r' 'u') ((λ c: char, if_f (c = 'r') '(' ')') x)) a);
    apply map_f_o_g;
    apply eq_sym;
    replace #1 (map (λ x: char, if_f (if_f (x = 'r') '(' ')' = '(') 'r' 'u') a) with (map (λ x: char, x) a);
    apply map_eq;
    intros x H;
    add_from_lib member_set_is_two_element_l;
    add_hyp member_set_is_two_element_l_ex := (member_set_is_two_element_l (char));
    add_hyp member_set_is_two_element_l_ex_ex := (member_set_is_two_element_l_ex (a));
    add_hyp member_set_is_two_element_l_ex_ex_ex := (member_set_is_two_element_l_ex_ex ('r'));
    add_hyp member_set_is_two_element_l_ex_ex_ex_ex := (member_set_is_two_element_l_ex_ex_ex ('u'));
    Seq (add_hyp (⁨|a| = cnt 'r' a + cnt 'u' a⁩)) (remove_hyp member_set_is_two_element_l_ex_ex_ex_ex) (Switch 1) (add_hyp member_set_is_two_element_l_ex_ex_ex_ex_o := (member_set_is_two_element_l_ex_ex_ex_ex H0)) (remove_hyp H0) (remove_hyp member_set_is_two_element_l_ex_ex_ex_ex);
    apply included_unfold in member_set_is_two_element_l_ex_ex_ex_ex_o;
    add_hyp member_set_is_two_element_l_ex_ex_ex_ex_o_ex := (member_set_is_two_element_l_ex_ex_ex_ex_o (x));
    Seq (add_hyp (⁨x ∈ member_set a⁩)) (remove_hyp member_set_is_two_element_l_ex_ex_ex_ex_o_ex) (Switch 1) (add_hyp member_set_is_two_element_l_ex_ex_ex_ex_o_ex_o := (member_set_is_two_element_l_ex_ex_ex_ex_o_ex H0)) (remove_hyp H0) (remove_hyp member_set_is_two_element_l_ex_ex_ex_ex_o_ex);
    apply union_unfold in member_set_is_two_element_l_ex_ex_ex_ex_o_ex_o;
    destruct member_set_is_two_element_l_ex_ex_ex_ex_o_ex_o with (or_ind ? ?);
    apply singleton_unfold in member_set_is_two_element_l_ex_ex_ex_ex_o_ex_o;
    apply eq_sym in member_set_is_two_element_l_ex_ex_ex_ex_o_ex_o;
    rewrite member_set_is_two_element_l_ex_ex_ex_ex_o_ex_o;
    replace #1 (if_f ('u' = 'r') '(' ')') with (')');
    apply if_false;
    Switch 1;
    apply if_false;
    assumption;
    assumption;
    apply singleton_unfold in member_set_is_two_element_l_ex_ex_ex_ex_o_ex_o;
    apply eq_sym in member_set_is_two_element_l_ex_ex_ex_ex_o_ex_o;
    rewrite member_set_is_two_element_l_ex_ex_ex_ex_o_ex_o;
    replace #1 (if_f ('r' = 'r') '(' ')') with ('(');
    apply if_true;
    auto_list;
    apply if_true;
    auto_list;
    apply inlist_member_set;
    assumption;
    lia;
    apply map_identity;
    intros;
    auto_list;
    apply set_from_func_fold;
    apply and_intro;
    apply and_intro;
    apply and_intro;
    intros;
    replace #1 ((firstn (map (λ c: char, if_f (c = 'r') '(' ')') a) i)) with (map (λ c: char, if_f (c = 'r') '(' ')') (firstn a i));
    apply firstn_map;
    replace #1 ((firstn (map (λ c: char, if_f (c = 'r') '(' ')') a) i)) with (map (λ c: char, if_f (c = 'r') '(' ')') (firstn a i));
    apply firstn_map;
    replace #1 (cnt ')' (map (λ c: char, if_f (c = 'r') '(' ')') (firstn a i))) with (cnt 'u'  (firstn a i));
    replace #1 (')') with ((λ c: char, if_f (c = 'r') '(' ')') 'u');
    apply eq_sym;
    apply if_false;
    assumption;
    apply (⁨cnt_of_map ?0 ?2 ?4 {'r', 'u'} ?8 ?10 ?12 ?14 ?16⁩);
    auto_set;
    add_hyp (⁨member_set (firstn a i) ⊆ member_set a);
    apply member_set_firstn;
    apply (⁨included_trans ?0 ?2 (member_set a) ?6 ?8 ?10⁩);
    apply member_set_is_two_element_l;
    lia;
    assumption;
    apply injective_fold;
    intros;
    revert H3;
    apply union_unfold in H1;
    destruct H1 with (or_ind ? ?);
    apply union_unfold in H2;
    destruct H2 with (or_ind ? ?);
    auto_set;
    replace #1 (if_f (x = 'r') '(' ')') with (')');
    apply singleton_unfold in H1;
    apply if_false;
    apply eq_sym in H1;
    rewrite H1;
    assumption;
    replace #1 (if_f (y = 'r') '(' ')') with ('(');
    apply singleton_unfold in H2;
    apply if_true;
    auto_set;
    assumption;
    apply union_unfold in H2;
    destruct H2 with (or_ind ? ?);
    replace #1 (if_f (x = 'r') '(' ')') with ('(');
    apply if_true;
    auto_set;
    replace #1 (if_f (y = 'r') '(' ')') with (')');
    apply if_false;
    apply singleton_unfold in H2;
    apply eq_sym in H2;
    rewrite H2;
    assumption;
    assumption;
    auto_set;
    replace #1 (cnt '(' (map (λ c: char, if_f (c = 'r') '(' ')') (firstn a i))) with (cnt 'r' (firstn a i));
    replace #1 ('(') with ((λ c: char, if_f (c = 'r') '(' ')') 'r');
    apply eq_sym;
    apply if_true;
    auto_list;
    add_from_lib cnt_of_map;
    add_hyp cnt_of_map_ex := (cnt_of_map (char));
    add_hyp cnt_of_map_ex_ex := (cnt_of_map_ex (char));
    add_hyp cnt_of_map_ex_ex_ex := (cnt_of_map_ex_ex ((λ c: char, if_f (c = 'r') '(' ')')));
    add_hyp cnt_of_map_ex_ex_ex_ex := (cnt_of_map_ex_ex_ex ({'r', 'u'}));
    apply cnt_of_map_ex_ex_ex_ex;
    auto_set;
    add_hyp (⁨member_set (firstn a i) ⊆ member_set a);
    apply member_set_firstn;
    apply (⁨included_trans ?0 ?2 (member_set a) ?6 ?8 ?10⁩);
    apply member_set_is_two_element_l;
    lia;
    assumption;
    apply injective_fold;
    intros;
    revert H3;
    apply union_unfold in H1;
    destruct H1 with (or_ind ? ?);
    apply union_unfold in H2;
    destruct H2 with (or_ind ? ?);
    auto_set;
    replace #1 (if_f (x = 'r') '(' ')') with (')');
    apply singleton_unfold in H1;
    apply if_false;
    apply eq_sym in H1;
    rewrite H1;
    assumption;
    replace #1 (if_f (y = 'r') '(' ')') with ('(');
    apply singleton_unfold in H2;
    apply if_true;
    auto_set;
    assumption;
    apply union_unfold in H2;
    destruct H2 with (or_ind ? ?);
    replace #1 (if_f (x = 'r') '(' ')') with ('(');
    apply if_true;
    auto_set;
    replace #1 (if_f (y = 'r') '(' ')') with (')');
    apply if_false;
    apply singleton_unfold in H2;
    apply eq_sym in H2;
    rewrite H2;
    assumption;
    assumption;
    auto_set;
    apply H_r_r_r;
    replace #1 (|map (λ c: char, if_f (c = 'r') '(' ')') a|) with (|a|) in H0;
    apply map_len;
    assumption;
    assumption;
    apply eq_sym in H_r_r_l;
    rewrite H_r_r_l;
    replace #1 (')') with ((λ c: char, if_f (c = 'r') '(' ')') 'u');
    apply eq_sym;
    apply if_false;
    assumption;
    apply (⁨cnt_of_map ?0 ?2 ?4 {'r', 'u'} ?8 ?10 ?12 ?14 ?16⁩);
    auto_set;
    apply member_set_is_two_element_l;
    lia;
    apply injective_fold;
    intros;
    apply union_unfold in H;
    apply union_unfold in H0;
    destruct H with (or_ind ? ?);
    destruct H0 with (or_ind ? ?);
    auto_set;
    replace #1 (if_f (x = 'r') '(' ')') with (')') in H1;
    apply singleton_unfold in H;
    apply if_false;
    apply eq_sym in H;
    rewrite H;
    assumption;
    apply singleton_unfold in H0;
    revert H1;
    replace #1 (if_f (y = 'r') '(' ')') with ('(');
    apply if_true;
    auto_set;
    lia;
    destruct H0 with (or_ind ? ?);
    apply singleton_unfold in H;
    apply singleton_unfold in H0;
    revert H1;
    replace #1 (if_f (x = 'r') '(' ')') with ('(');
    apply if_true;
    auto_set;
    replace #1 (if_f (y = 'r') '(' ')') with (')');
    apply if_false;
    apply eq_sym in H0;
    rewrite H0;
    assumption;
    assumption;
    auto_set;
    apply eq_sym in H_r_l;
    rewrite H_r_l;
    replace #1 ('(') with ((λ c: char, if_f (c = 'r') '(' ')') 'r');
    apply eq_sym;
    apply if_true;
    auto_list;
    apply (⁨cnt_of_map ?0 ?2 ?4 {'r', 'u'} ?8 ?10 ?12 ?14 ?16⁩);
    auto_set;
    apply member_set_is_two_element_l;
    lia;
    apply injective_fold;
    intros;
    apply union_unfold in H;
    apply union_unfold in H0;
    destruct H with (or_ind ? ?);
    destruct H0 with (or_ind ? ?);
    auto_set;
    replace #1 (if_f (x = 'r') '(' ')') with (')') in H1;
    apply singleton_unfold in H;
    apply if_false;
    apply eq_sym in H;
    rewrite H;
    assumption;
    apply singleton_unfold in H0;
    revert H1;
    replace #1 (if_f (y = 'r') '(' ')') with ('(');
    apply if_true;
    auto_set;
    lia;
    destruct H0 with (or_ind ? ?);
    apply singleton_unfold in H;
    apply singleton_unfold in H0;
    revert H1;
    replace #1 (if_f (x = 'r') '(' ')') with ('(');
    apply if_true;
    auto_set;
    replace #1 (if_f (y = 'r') '(' ')') with (')');
    apply if_false;
    apply eq_sym in H0;
    rewrite H0;
    assumption;
    assumption;
    auto_set;
    replace #1 (|map (λ c: char, if_f (c = 'r') '(' ')') a|) with (|a|);
    apply map_len;
    assumption;
    apply included_fold;
    intros;
    apply set_from_func_fold;
    apply projection_in_intro_l in H;
    destruct H with (ex_ind ? ?) to (x x_property);
    destruct x_property with (and_ind ? ?) to (x_property_l x_property_r);
    apply set_from_func_unfold in x_property_l;
    destruct x_property_l with (and_ind ? ?) to (x_property_l_l x_property_l_r);
    destruct x_property_l_r with (and_ind ? ?) to (x_property_l_r_l x_property_l_r_r);
    destruct x_property_l_r_r with (and_ind ? ?) to (x_property_l_r_r_l x_property_l_r_r_r);
    rewrite x_property_r;
    apply and_intro;
    apply and_intro;
    apply and_intro;
    intros;
    add_hyp x_property_l_r_r_r_ex := (x_property_l_r_r_r (i));
    replace #1 (cnt 'u' (firstn (map (λ c: char, if_f (c = '(') 'r' 'u') x) i)) with (cnt ')' (firstn x i));
    replace #1 ((firstn (map (λ c: char, if_f (c = '(') 'r' 'u') x) i)) with (map (λ c: char, if_f (c = '(') 'r' 'u') (firstn  x i));
    apply firstn_map;
    apply (⁨cnt_of_map ?0 ?2 ?4 {'(', ')'} ?8 ?10 ?12 ?14 ?16⁩);
    auto_set;
    apply (⁨included_trans ?0 ?2 (member_set x) ?6 ?8 ?10⁩);
    apply member_set_is_two_element_l;
    lia;
    apply member_set_firstn;
    apply injective_fold;
    intros;
    apply union_unfold in H1;
    apply union_unfold in H2;
    destruct H1 with (or_ind ? ?);
    destruct H2 with (or_ind ? ?);
    auto_set;
    revert H3;
    apply singleton_unfold in H1;
    apply singleton_unfold in H2;
    apply eq_sym in H2;
    rewrite H2;
    apply eq_sym in H1;
    rewrite H1;
    replace #1 (if_f (')' = '(') 'r' 'u') with ('u');
    apply if_false;
    assumption;
    replace #1 (if_f ('(' = '(') 'r' 'u') with ('r');
    apply if_true;
    auto_list;
    assumption;
    destruct H2 with (or_ind ? ?);
    revert H3;
    apply singleton_unfold in H1;
    apply singleton_unfold in H2;
    apply eq_sym in H2;
    rewrite H2;
    apply eq_sym in H1;
    rewrite H1;
    replace #1 (if_f (')' = '(') 'r' 'u') with ('u');
    apply if_false;
    assumption;
    replace #1 (if_f ('(' = '(') 'r' 'u') with ('r');
    apply if_true;
    auto_list;
    assumption;
    auto_set;
    replace #1 (cnt 'r' (firstn (map (λ c: char, if_f (c = '(') 'r' 'u') x) i)) with (cnt '(' (firstn x i));
    replace #1 (firstn (map (λ c: char, if_f (c = '(') 'r' 'u') x) i) with (map (λ c: char, if_f (c = '(') 'r' 'u') (firstn x i));
    apply firstn_map;
    apply (⁨cnt_of_map ?0 ?2 ?4 {'(', ')'} ?8 ?10 ?12 ?14 ?16⁩);
    auto_set;
    apply (⁨included_trans ?0 ?2 (member_set x) ?6 ?8 ?10⁩);
    apply member_set_is_two_element_l;
    lia;
    apply member_set_firstn;
    apply injective_fold;
    intros;
    apply union_unfold in H1;
    apply union_unfold in H2;
    destruct H1 with (or_ind ? ?);
    destruct H2 with (or_ind ? ?);
    auto_set;
    revert H3;
    apply singleton_unfold in H1;
    apply singleton_unfold in H2;
    apply eq_sym in H2;
    rewrite H2;
    apply eq_sym in H1;
    rewrite H1;
    replace #1 (if_f (')' = '(') 'r' 'u') with ('u');
    apply if_false;
    assumption;
    replace #1 (if_f ('(' = '(') 'r' 'u') with ('r');
    apply if_true;
    auto_list;
    assumption;
    destruct H2 with (or_ind ? ?);
    revert H3;
    apply singleton_unfold in H1;
    apply singleton_unfold in H2;
    apply eq_sym in H2;
    rewrite H2;
    apply eq_sym in H1;
    rewrite H1;
    replace #1 (if_f (')' = '(') 'r' 'u') with ('u');
    apply if_false;
    assumption;
    replace #1 (if_f ('(' = '(') 'r' 'u') with ('r');
    apply if_true;
    auto_list;
    assumption;
    auto_set;
    apply x_property_l_r_r_r_ex;
    replace #1 (|map (λ c: char, if_f (c = '(') 'r' 'u') x|) with (|x|) in H0;
    apply map_len;
    assumption;
    assumption;
    replace #1 (cnt 'u' (map (λ c: char, if_f (c = '(') 'r' 'u') x)) with (cnt ')' x);
    apply (⁨cnt_of_map ?0 ?2 ?4 {'(', ')'} ?8 ?10 ?12 ?14 ?16⁩);
    auto_set;
    apply member_set_is_two_element_l;
    lia;
    apply injective_fold;
    intros;
    apply union_unfold in H;
    apply union_unfold in H0;
    destruct H with (or_ind ? ?);
    destruct H0 with (or_ind ? ?);
    auto_set;
    revert H1;
    apply singleton_unfold in H;
    apply singleton_unfold in H0;
    apply eq_sym in H;
    apply eq_sym in H0;
    rewrite H;
    rewrite H0;
    replace #1 (if_f (')' = '(') 'r' 'u') with ('u');
    apply if_false;
    assumption;
    replace #1 (if_f ('(' = '(') 'r' 'u') with ('r');
    apply if_true;
    auto_list;
    assumption;
    destruct H0 with (or_ind ? ?);
    revert H1;
    apply singleton_unfold in H;
    apply singleton_unfold in H0;
    apply eq_sym in H;
    apply eq_sym in H0;
    rewrite H;
    rewrite H0;
    replace #1 (if_f (')' = '(') 'r' 'u') with ('u');
    apply if_false;
    assumption;
    replace #1 (if_f ('(' = '(') 'r' 'u') with ('r');
    apply if_true;
    auto_list;
    assumption;
    auto_set;
    assumption;
    replace #1 (cnt 'r' (map (λ c: char, if_f (c = '(') 'r' 'u') x)) with (cnt '(' x);
    apply (⁨cnt_of_map ?0 ?2 ?4 {'(', ')'} ?8 ?10 ?12 ?14 ?16⁩);
    auto_set;
    apply member_set_is_two_element_l;
    lia;
    apply injective_fold;
    intros;
    apply union_unfold in H;
    apply union_unfold in H0;
    destruct H with (or_ind ? ?);
    destruct H0 with (or_ind ? ?);
    auto_set;
    revert H1;
    apply singleton_unfold in H;
    apply singleton_unfold in H0;
    apply eq_sym in H;
    apply eq_sym in H0;
    rewrite H;
    rewrite H0;
    replace #1 (if_f (')' = '(') 'r' 'u') with ('u');
    apply if_false;
    assumption;
    replace #1 (if_f ('(' = '(') 'r' 'u') with ('r');
    apply if_true;
    auto_list;
    assumption;
    destruct H0 with (or_ind ? ?);
    revert H1;
    apply singleton_unfold in H;
    apply singleton_unfold in H0;
    apply eq_sym in H;
    apply eq_sym in H0;
    rewrite H;
    rewrite H0;
    replace #1 (if_f (')' = '(') 'r' 'u') with ('u');
    apply if_false;
    assumption;
    replace #1 (if_f ('(' = '(') 'r' 'u') with ('r');
    apply if_true;
    auto_list;
    assumption;
    auto_set;
    assumption;
    replace #1 (|map (λ c: char, if_f (c = '(') 'r' 'u') x|) with (|x|);
    apply map_len;
    assumption;
    apply (⁨rule_of_minus2 ?0 { l: list char | |l| = 2 * n   ∧ cnt 'r' l = n ∧ cnt 'u' l = n } ?14 (cm (2 * n) n) (cm (2 * n) (n   - 1)) ?18 ?20 ?22 ?24 ?26 ?28 ?30⁩);
    auto_list;
    apply included_fold;
    intros;
    apply set_from_func_unfold in H;
    apply set_from_func_fold;
    assumption;
    add_from_lib exist_function;
    add_hyp exist_function_ex := (exist_function (list char));
    add_hyp exist_function_ex_ex := (exist_function_ex (list char));
    add_hyp exist_function_ex_ex_ex := (exist_function_ex_ex (λ x y, x ∈ { l: list char | |l| = 2 * n ∧ cnt 'r' l = n ∧ cnt 'u' l = n } ∖ { l: list char | |l| = 2 * n ∧ cnt 'r' l = n ∧ cnt 'u' l = n ∧ ∀ i: ℤ, 0 < i → i ≤ |l| → cnt 'u' (firstn l i) ≤ cnt 'r' (firstn l i) } -> ∃ i, i > 0 ∧ i ≤ |x| ∧ cnt 'r' (firstn x i) + 1 = cnt 'u' (firstn x i) ∧ (∀ j, j > 0 -> cnt 'r' (firstn x j) + 1 = cnt 'u' (firstn x j) -> j ≥ i) ∧ (∀ j, j > 0 -> cnt 'u' (firstn y j) + 1 = cnt 'r' (firstn y j) -> j ≥ i) ∧ y = (map (λ c, if_f (c = 'r') 'u' 'r') (firstn x i) ) + skipn x i ));
    Seq (add_hyp (⁨∀ x: list char,   ∃ x0: list char,     (λ x1 y: list char,       x1         ∈ { l: list char | |l| = 2 * n ∧ cnt 'r' l = n ∧ cnt 'u' l = n }             ∖ { l: list char | |l| = 2 * n                 ∧ cnt 'r' l = n                     ∧ cnt 'u' l = n                         ∧ ∀ i: ℤ,                             0 < i                               → i ≤ |l|                                   → cnt 'u' (firstn l i)                                       ≤ cnt 'r' (firstn l i) }         → ∃ i: ℤ,             0 < i               ∧ i ≤ |x1|                   ∧ cnt 'r' (firstn x1 i) + 1 = cnt 'u' (firstn x1 i)                       ∧ (∀ j: ℤ,                           0 < j                             → cnt 'r' (firstn x1 j) + 1 = cnt 'u' (firstn x1 j)                                 → i ≤ j)                           ∧ (∀ j: ℤ,                               0 < j                                 → cnt 'u' (firstn y j) + 1                                     = cnt 'r' (firstn y j)                                     → i ≤ j)                               ∧ y                                   = map (λ c: char,                                       if_f (c = 'r') 'u' 'r') (firstn x1 i)                                       + skipn x1 i) x x0⁩)) (remove_hyp exist_function_ex_ex_ex) (Switch 1) (add_hyp exist_function_ex_ex_ex_o := (exist_function_ex_ex_ex H)) (remove_hyp H) (remove_hyp exist_function_ex_ex_ex);
    Switch 1;
    intros;
    add_hyp (x ∈ { l: list char | |l| = 2 * n ∧ cnt 'r' l = n ∧ cnt 'u' l = n } ∖ { l: list char | |l| = 2 * n ∧ cnt 'r' l = n ∧ cnt 'u' l = n ∧ ∀ i: ℤ, 0 < i → i ≤ |l| → cnt 'u' (firstn l i) ≤ cnt 'r' (firstn l i) } ∨ ~ x ∈ { l: list char | |l| = 2 * n ∧ cnt 'r' l = n ∧ cnt 'u' l = n } ∖ { l: list char | |l| = 2 * n ∧ cnt 'r' l = n ∧ cnt 'u' l = n ∧ ∀ i: ℤ, 0 < i → i ≤ |l| → cnt 'u' (firstn l i) ≤ cnt 'r' (firstn l i) });
    assumption;
    destruct H with (or_ind ? ?);
    apply (ex_intro ? ? ([]));
    intros;
    assumption;
    apply setminus_unfold in H;
    destruct H with (and_ind ? ?) to (H_l H_r);
    add_hyp (~ ∀ i: ℤ, 0 < i → i ≤ |x| → cnt 'u' (firstn x i) ≤ cnt 'r' (firstn x i) );
    intros;
    Seq (add_hyp (⁨x   ∈ { l: list char | |l| = 2 * n       ∧ cnt 'r' l = n           ∧ cnt 'u' l = n               ∧ ∀ i: ℤ,                   0 < i                     → i ≤ |l| → cnt 'u' (firstn l i) ≤ cnt 'r' (firstn l i) }⁩)) (remove_hyp H_r) (Switch 1) (add_hyp H_r_o := (H_r H0)) (remove_hyp H0) (remove_hyp H_r);
    assumption;
    apply set_from_func_fold;
    apply set_from_func_unfold in H_l;
    assumption;
    apply not_forall_imply_exists in H;
    add_hyp (∃ i: ℤ, -1 < i ∧ i ≤ |x| ∧ cnt 'r' (firstn x i) + 1 = cnt 'u' (firstn x i));
    add_hyp (∃ i: ℤ, -1 < i ∧ i ≤ |x| ∧ cnt 'r' (firstn x i) < cnt 'u' (firstn x i));
    destruct H with (ex_ind ? ?) to (i i_property);
    apply not_forall_imply_exists in i_property;
    destruct i_property with (ex_ind ? ?) to (h1 h1_property);
    apply not_forall_imply_exists in h1_property;
    destruct h1_property with (ex_ind ? ?) to (h2 h2_property);
    apply (ex_intro ? ? (i));
    lia;
    apply ex_min in H0;
    destruct H0 with (ex_ind ? ?) to (i i_property);
    apply (ex_intro ? ? (i));
    destruct i_property with (and_ind ? ?) to (i_property_l i_property_r);
    destruct i_property_r with (and_ind ? ?) to (i_property_r_l i_property_r_r);
    apply and_intro;
    apply NNPP;
    intros;
    add_hyp i_property_r_r_ex := (i_property_r_r (i - 1));
    Seq (add_hyp (⁨- 1 < i - 1⁩)) (remove_hyp i_property_r_r_ex) (Switch 1) (add_hyp i_property_r_r_ex_o := (i_property_r_r_ex H1)) (remove_hyp H1) (remove_hyp i_property_r_r_ex);
    Seq (add_hyp (⁨i - 1 ≤ |x| ∧ cnt 'r' (firstn x (i - 1)) < cnt 'u' (firstn x (i - 1))⁩)) (remove_hyp i_property_r_r_ex_o) (Switch 1) (add_hyp i_property_r_r_ex_o_o := (i_property_r_r_ex_o H1)) (remove_hyp H1) (remove_hyp i_property_r_r_ex_o);
    lia;
    apply and_intro;
    add_from_lib cnt_of_firstn_dis_range;
    add_hyp cnt_of_firstn_dis_range_ex := (cnt_of_firstn_dis_range (char));
    add_hyp cnt_of_firstn_dis_range_ex_ex := (cnt_of_firstn_dis_range_ex (x));
    add_hyp cnt_of_firstn_dis_range_ex_ex_ex := (cnt_of_firstn_dis_range_ex_ex (i));
    add_hyp cnt_of_firstn_dis_range_ex_ex_ex_ex := (cnt_of_firstn_dis_range_ex_ex_ex ('r'));
    add_hyp cnt_of_firstn_dis_range_ex_ex_ex_ex0 := (cnt_of_firstn_dis_range_ex_ex_ex ('u'));
    destruct i_property_r_l with (and_ind ? ?) to (i_property_r_l_l i_property_r_l_r);
    lia;
    lia;
    add_hyp (~ i = 0);
    intros;
    replace #1 ((firstn x i)) with ([]) in i_property_r_l;
    apply firstn_le_0;
    assumption;
    replace #1 ((firstn x i)) with ([]) in i_property_r_l;
    apply firstn_le_0;
    assumption;
    lia;
    lia;
    assumption;
    apply ex_min in H0;
    destruct H0 with (ex_ind ? ?) to (i i_property);
    add_hyp (∃ x, x = (λ c: char, if_f (c = 'r') 'u' 'r'));
    apply (ex_intro ? ? ((λ c: char, if_f (c = 'r') 'u' 'r')));
    auto_list;
    destruct H0 with (ex_ind ? ?) to (revert revert_property);
    apply (ex_intro ? ? (map revert (firstn x i) + skipn x i));
    intros;
    apply (ex_intro ? ? (i));
    destruct i_property with (and_ind ? ?) to (i_property_l i_property_r);
    apply and_intro;
    destruct i_property_r with (and_ind ? ?) to (i_property_r_l i_property_r_r);
    apply and_intro;
    apply and_intro;
    apply and_intro;
    apply and_intro;
    rewrite revert_property;
    auto_list;
    intros;
    apply NNPP;
    intros;
    replace #1 ((firstn (map revert (firstn x i) + skipn x i) j)) with (map revert (firstn x j)) in H2;
    replace #1 (firstn (map revert (firstn x i) + skipn x i) j) with (firstn (map revert (firstn x i)) j);
    apply firstn_append_l;
    replace #1 (|map revert (firstn x i)|) with (i);
    replace #1 (|map revert (firstn x i)|) with (|(firstn x i)|);
    apply map_len;
    apply len_firstn;
    assumption;
    lia;
    lia;
    replace #1 (firstn (map revert (firstn x i)) j) with (map revert (firstn (firstn x i) j));
    apply firstn_map;
    replace #1 ((firstn (firstn x i) j)) with ((firstn x j));
    apply firstn_firstn;
    lia;
    auto_list;
    replace #1 ((firstn (map revert (firstn x i) + skipn x i) j)) with ((map revert (firstn x j))) in H2;
    replace #1 (firstn (map revert (firstn x i) + skipn x i) j) with (firstn (map revert (firstn x i)) j);
    apply firstn_append_l;
    replace #1 (|map revert (firstn x i)|) with (i);
    replace #1 (|map revert (firstn x i)|) with (|(firstn x i)|);
    apply map_len;
    apply len_firstn;
    assumption;
    lia;
    lia;
    replace #1 (firstn (map revert (firstn x i)) j) with (map revert (firstn (firstn x i) j));
    apply firstn_map;
    replace #1 ((firstn (firstn x i) j)) with ((firstn x j));
    apply firstn_firstn;
    lia;
    auto_list;
    replace #1 (cnt 'u' (map revert (firstn x j))) with (cnt 'r' (firstn x j)) in H2;
    apply (⁨cnt_of_map ?0 ?2 ?4 {'r', 'u'} ?8 ?10 ?12 ?14 ?16⁩);
    auto_set;
    apply (⁨included_trans ?0 ?2 (member_set x) ?6 ?8 ?10⁩);
    apply member_set_is_two_element_l;
    apply set_from_func_unfold in H_l;
    lia;
    apply member_set_firstn;
    apply injective_fold;
    intros;
    apply union_unfold in H4;
    apply union_unfold in H5;
    destruct H4 with (or_ind ? ?);
    destruct H5 with (or_ind ? ?);
    auto_set;
    replace #1 (x0) with ('u') in H6;
    auto_set;
    replace #1 (y) with ('r') in H6;
    auto_set;
    replace #1 (revert 'r') with ('u') in H6;
    rewrite revert_property;
    apply if_true;
    auto_list;
    replace #1 (revert 'u') with ('r') in H6;
    rewrite revert_property;
    apply if_false;
    assumption;
    assumption;
    destruct H5 with (or_ind ? ?);
    replace #1 (x0) with ('r') in H6;
    auto_set;
    replace #1 (y) with ('u') in H6;
    auto_set;
    replace #1 (revert 'r') with ('u') in H6;
    rewrite revert_property;
    apply if_true;
    auto_list;
    replace #1 (revert 'u') with ('r') in H6;
    rewrite revert_property;
    apply if_false;
    assumption;
    assumption;
    auto_set;
    replace #1 (cnt 'r' (map revert (firstn x j))) with (cnt 'u' ((firstn x j))) in H2;
    apply (⁨cnt_of_map ?0 ?2 ?4 {'r', 'u'} ?8 ?10 ?12 ?14 ?16⁩);
    auto_set;
    apply (⁨included_trans ?0 ?2 (member_set x) ?6 ?8 ?10⁩);
    apply member_set_is_two_element_l;
    apply set_from_func_unfold in H_l;
    lia;
    apply member_set_firstn;
    apply injective_fold;
    intros;
    apply union_unfold in H4;
    apply union_unfold in H5;
    destruct H4 with (or_ind ? ?);
    destruct H5 with (or_ind ? ?);
    auto_set;
    replace #1 (x0) with ('u') in H6;
    auto_set;
    replace #1 (y) with ('r') in H6;
    auto_set;
    replace #1 (revert 'r') with ('u') in H6;
    rewrite revert_property;
    apply if_true;
    auto_list;
    replace #1 (revert 'u') with ('r') in H6;
    rewrite revert_property;
    apply if_false;
    assumption;
    assumption;
    destruct H5 with (or_ind ? ?);
    replace #1 (x0) with ('r') in H6;
    auto_set;
    replace #1 (y) with ('u') in H6;
    auto_set;
    replace #1 (revert 'r') with ('u') in H6;
    rewrite revert_property;
    apply if_true;
    auto_list;
    replace #1 (revert 'u') with ('r') in H6;
    rewrite revert_property;
    apply if_false;
    assumption;
    assumption;
    auto_set;
    add_hyp i_property_r_r_ex := (i_property_r_r (j));
    lia;
    intros;
    apply NNPP;
    intros;
    apply set_from_func_unfold in H_l;
    intros;
    intros;
    add_hyp i_property_r_r_ex := (i_property_r_r (j));
    lia;
    assumption;
    assumption;
    add_hyp (~ i = 0);
    intros;
    destruct i_property_r with (and_ind ? ?) to (i_property_r_l i_property_r_r);
    replace #1 ((firstn x i)) with ([]) in i_property_r_l;
    apply firstn_le_0;
    assumption;
    replace #1 ((firstn x i)) with ([]) in i_property_r_l;
    apply firstn_le_0;
    assumption;
    lia;
    lia;
    remove_hyp exist_function_ex_ex;
    remove_hyp exist_function_ex;
    destruct exist_function_ex_ex_ex_o with (ex_ind ? ?) to (f f_property);
    add_hyp (∃ x, x = (λ c: char, if_f (c = 'r') 'u' 'r'));
    apply (ex_intro ? ? ((λ c: char, if_f (c = 'r') 'u' 'r')));
    auto_list;
    destruct H with (ex_ind ? ?) to (revert revert_property);
    apply (⁨rule_of_bijectionR ?0 (list char) f ?4 ?6 ?8 ?10 ?12⁩);
    replace #1 (projection ({ l: list char | |l| = 2 * n ∧ cnt 'r' l = n ∧ cnt 'u' l = n } ∖ { l: list char | |l| = 2 * n ∧ cnt 'r' l = n ∧ cnt 'u' l = n ∧ ∀ i: ℤ, 0 < i → i ≤ |l| → cnt 'u' (firstn l i) ≤ cnt 'r' (firstn l i) }) f) with ({ l: list char | cnt 'r' l = n + 1 ∧ cnt 'u' l =  n - 1 ∧ |l| = n + 1 + (n - 1) });
    apply set_equality;
    apply included_fold;
    intros;
    apply set_from_func_unfold in H;
    destruct H with (and_ind ? ?) to (H_l H_r);
    destruct H_r with (and_ind ? ?) to (H_r_l H_r_r);
    add_hyp (∃ i, i > -1 ∧ i ≤ |a| ∧ cnt 'r' (firstn a i) = cnt 'u' (firstn a i) + 1);
    add_hyp (∃ i: ℤ, - 1 < i ∧ i ≤ |a| ∧ cnt 'r' (firstn a i) > cnt 'u' (firstn a i));
    apply (ex_intro ? ? (2 * n));
    apply and_intro;
    apply and_intro;
    replace #2 (firstn a (2 * n)) with (a);
    replace #1 ((2 * n)) with (|a|);
    lia;
    apply firstn_len;
    replace #1 ((firstn a (2 * n))) with (a);
    replace #1 ((2 * n)) with (|a|);
    lia;
    apply firstn_len;
    lia;
    lia;
    lia;
    apply ex_min in H;
    destruct H with (ex_ind ? ?) to (i i_property);
    apply (ex_intro ? ? (i));
    apply and_intro;
    apply and_intro;
    destruct i_property with (and_ind ? ?) to (i_property_l i_property_r);
    destruct i_property_r with (and_ind ? ?) to (i_property_r_l i_property_r_r);
    apply NNPP;
    intros;
    add_hyp i_property_r_r_ex := (i_property_r_r (i - 1));
    Seq (add_hyp (⁨- 1 < i - 1⁩)) (remove_hyp i_property_r_r_ex) (Switch 1) (add_hyp i_property_r_r_ex_o := (i_property_r_r_ex H0)) (remove_hyp H0) (remove_hyp i_property_r_r_ex);
    Seq (add_hyp (⁨i - 1 ≤ |a| ∧ cnt 'u' (firstn a (i - 1)) < cnt 'r' (firstn a (i - 1))⁩)) (remove_hyp i_property_r_r_ex_o) (Switch 1) (add_hyp i_property_r_r_ex_o_o := (i_property_r_r_ex_o H0)) (remove_hyp H0) (remove_hyp i_property_r_r_ex_o);
    lia;
    apply and_intro;
    add_from_lib cnt_of_firstn_dis_range;
    add_hyp cnt_of_firstn_dis_range_ex := (cnt_of_firstn_dis_range (char));
    add_hyp cnt_of_firstn_dis_range_ex_ex := (cnt_of_firstn_dis_range_ex (a));
    add_hyp cnt_of_firstn_dis_range_ex_ex_ex := (cnt_of_firstn_dis_range_ex_ex (i));
    add_hyp cnt_of_firstn_dis_range_ex_ex_ex_ex := (cnt_of_firstn_dis_range_ex_ex_ex ('r'));
    add_hyp cnt_of_firstn_dis_range_ex_ex_ex_ex0 := (cnt_of_firstn_dis_range_ex_ex_ex ('u'));
    lia;
    lia;
    add_hyp (~ i = 0);
    intros;
    replace #1 ((firstn a i)) with ([]) in i_property_r_l;
    apply firstn_le_0;
    assumption;
    replace #1 ((firstn a i)) with ([]) in i_property_r_l;
    apply firstn_le_0;
    assumption;
    lia;
    lia;
    assumption;
    assumption;
    apply ex_min in H;
    destruct H with (ex_ind ? ?) to (i i_property);
    destruct i_property with (and_ind ? ?) to (i_property_l i_property_r);
    destruct i_property_r with (and_ind ? ?) to (i_property_r_l i_property_r_r);
    apply projection_in_intro_r;
    apply (ex_intro ? ? (map revert (firstn a i) + skipn a i));
    apply and_intro;
    add_hyp (|map revert (firstn a i) + skipn a i| = 2 * n);
    replace #1 (|map revert (firstn a i) + skipn a i|) with (|map revert (firstn a i) |+| skipn a i|);
    lia;
    replace #1 (|map revert (firstn a i)|) with (|(firstn a i)|);
    apply map_len;
    replace #1 (|firstn a i| + |skipn a i|) with (|firstn a i + skipn a i|);
    lia;
    replace #1 (firstn a i + skipn a i) with (a);
    apply eq_sym;
    apply firstn_skipn;
    lia;
    add_hyp (∀ c, c ∈ {'r', 'u'} -> cnt c ( map revert (firstn a i) + skipn a i) = n);
    intros;
    replace #1 (cnt c (map revert (firstn a i) + skipn a i)) with (cnt c (map revert (firstn a i)) + cnt c ( skipn a i));
    lia;
    apply union_unfold in H0;
    destruct H0 with (or_ind ? ?);
    apply singleton_unfold in H0;
    apply eq_sym in H0;
    rewrite H0;
    replace #1 (a) with (firstn a i + skipn a i) in H_r_l;
    apply firstn_skipn;
    replace #1 (cnt 'u' (map revert (firstn a i))) with (cnt 'r' (firstn a i));
    apply (⁨cnt_of_map ?0 ?2 ?4 {'r', 'u'} ?8 ?10 ?12 ?14 ?16⁩);
    auto_set;
    apply (⁨included_trans ?0 ?2 (member_set a) ?6 ?8 ?10⁩);
    apply member_set_is_two_element_l;
    replace #1 (firstn a i + skipn a i) with (a) in H_r_l;
    apply eq_sym;
    apply firstn_skipn;
    lia;
    apply member_set_firstn;
    apply injective_fold;
    intros;
    apply union_unfold in H1;
    apply union_unfold in H2;
    destruct H1 with (or_ind ? ?);
    destruct H2 with (or_ind ? ?);
    auto_set;
    revert H3;
    apply singleton_unfold in H1;
    apply eq_sym in H1;
    apply singleton_unfold in H2;
    apply eq_sym in H2;
    rewrite H1;
    apply eq_sym in H1;
    rewrite H2;
    replace #1 (revert 'u') with ('r');
    rewrite revert_property;
    apply if_false;
    assumption;
    replace #1 (revert 'r') with ('u');
    rewrite revert_property;
    apply if_true;
    auto_list;
    assumption;
    destruct H2 with (or_ind ? ?);
    revert H3;
    apply singleton_unfold in H1;
    apply eq_sym in H1;
    apply singleton_unfold in H2;
    apply eq_sym in H2;
    rewrite H1;
    apply eq_sym in H1;
    rewrite H2;
    replace #1 (revert 'u') with ('r');
    rewrite revert_property;
    apply if_false;
    assumption;
    replace #1 (revert 'r') with ('u');
    rewrite revert_property;
    apply if_true;
    auto_list;
    assumption;
    auto_set;
    lia;
    apply singleton_unfold in H0;
    apply eq_sym in H0;
    rewrite H0;
    replace #1 (cnt 'r' (map revert (firstn a i))) with (cnt 'u' (firstn a i));
    apply (⁨cnt_of_map ?0 ?2 ?4 {'r', 'u'} ?8 ?10 ?12 ?14 ?16⁩);
    auto_set;
    add_hyp (⁨member_set (firstn a i) ⊆ member_set a);
    apply member_set_firstn;
    apply (⁨included_trans ?0 ?2 (member_set a) ?6 ?8 ?10⁩);
    apply member_set_is_two_element_l;
    lia;
    assumption;
    apply injective_fold;
    intros;
    apply union_unfold in H1;
    apply union_unfold in H2;
    destruct H1 with (or_ind ? ?);
    destruct H2 with (or_ind ? ?);
    auto_set;
    revert H3;
    apply singleton_unfold in H1;
    apply eq_sym in H1;
    apply singleton_unfold in H2;
    apply eq_sym in H2;
    rewrite H1;
    apply eq_sym in H1;
    apply eq_sym in H1;
    rewrite H2;
    replace #1 (revert 'u') with ('r');
    rewrite revert_property;
    apply if_false;
    assumption;
    replace #1 (revert 'r') with ('u');
    rewrite revert_property;
    apply if_true;
    auto_list;
    assumption;
    destruct H2 with (or_ind ? ?);
    revert H3;
    apply singleton_unfold in H1;
    apply eq_sym in H1;
    apply singleton_unfold in H2;
    apply eq_sym in H2;
    rewrite H1;
    apply eq_sym in H1;
    rewrite H2;
    replace #1 (revert 'u') with ('r');
    rewrite revert_property;
    apply if_false;
    assumption;
    replace #1 (revert 'r') with ('u');
    rewrite revert_property;
    apply if_true;
    auto_list;
    assumption;
    revert H3;
    apply singleton_unfold in H1;
    apply eq_sym in H1;
    apply singleton_unfold in H2;
    apply eq_sym in H2;
    rewrite H1;
    apply eq_sym in H1;
    rewrite H2;
    rewrite revert_property;
    auto_list;
    replace #1 (a) with (firstn a i + skipn a i) in H_l;
    apply firstn_skipn;
    lia;
    add_hyp f_property_ex := (f_property ( (map revert (firstn a i) + skipn a i)));
    Seq (add_hyp (⁨map revert (firstn a i) + skipn a i   ∈ { l: list char | |l| = 2 * n ∧ cnt 'r' l = n ∧ cnt 'u' l = n }       ∖ { l: list char | |l| = 2 * n           ∧ cnt 'r' l = n               ∧ cnt 'u' l = n                   ∧ ∀ i0: ℤ,                       0 < i0                         → i0 ≤ |l|                             → cnt 'u' (firstn l i0) ≤ cnt 'r' (firstn l i0) }⁩)) (remove_hyp f_property_ex) (Switch 1) (add_hyp f_property_ex_o := (f_property_ex H1)) (remove_hyp H1) (remove_hyp f_property_ex);
    destruct f_property_ex_o with (ex_ind ? ?) to (j j_property);
    destruct j_property with (and_ind ? ?) to (j_property_l j_property_r);
    destruct j_property_r with (and_ind ? ?) to (j_property_r_l j_property_r_r);
    destruct j_property_r_r with (and_ind ? ?) to (j_property_r_r_l j_property_r_r_r);
    destruct j_property_r_r_r with (and_ind ? ?) to (j_property_r_r_r_l j_property_r_r_r_r);
    destruct j_property_r_r_r_r with (and_ind ? ?) to (j_property_r_r_r_r_l j_property_r_r_r_r_r);
    add_hyp (i = j);
    add_hyp i_property_r_r_ex := (i_property_r_r (j));
    add_hyp j_property_r_r_r_l_ex := (j_property_r_r_r_l (i));
    Seq (add_hyp (⁨0 < i⁩)) (remove_hyp j_property_r_r_r_l_ex) (Switch 1) (add_hyp j_property_r_r_r_l_ex_o := (j_property_r_r_r_l_ex H1)) (remove_hyp H1) (remove_hyp j_property_r_r_r_l_ex);
    Seq (add_hyp (⁨cnt 'r' (firstn (map revert (firstn a i) + skipn a i) i) + 1   = cnt 'u' (firstn (map revert (firstn a i) + skipn a i) i)⁩)) (remove_hyp j_property_r_r_r_l_ex_o) (Switch 1) (add_hyp j_property_r_r_r_l_ex_o_o := (j_property_r_r_r_l_ex_o H1)) (remove_hyp H1) (remove_hyp j_property_r_r_r_l_ex_o);
    Switch 1;
    replace #1 ((firstn (map revert (firstn a i) + skipn a i) i)) with ((firstn (map revert (firstn a i)) i));
    apply firstn_append_l;
    replace #1 (|map revert (firstn a i)|) with (| (firstn a i)|);
    apply map_len;
    replace #1 (|firstn a i|) with (i);
    apply len_firstn;
    assumption;
    lia;
    auto_list;
    replace #1 ((firstn (map revert (firstn a i) + skipn a i) i)) with ((firstn (map revert (firstn a i)) i));
    apply firstn_append_l;
    replace #1 (|map revert (firstn a i)|) with (| (firstn a i)|);
    apply map_len;
    replace #1 (|firstn a i|) with (i);
    apply len_firstn;
    assumption;
    lia;
    auto_list;
    replace #1 ((firstn (map revert (firstn a i)) i)) with (map revert (firstn a i));
    replace #2 (i) with (|(map revert (firstn a i))|);
    replace #1 (|map revert (firstn a i)|) with (| (firstn a i)|);
    apply map_len;
    apply eq_sym;
    apply len_firstn;
    assumption;
    lia;
    apply firstn_len;
    replace #1 ((firstn (map revert (firstn a i)) i)) with (map revert (firstn a i));
    replace #2 (i) with (|(map revert (firstn a i))|);
    replace #1 (|map revert (firstn a i)|) with (| (firstn a i)|);
    apply map_len;
    apply eq_sym;
    apply len_firstn;
    assumption;
    lia;
    apply firstn_len;
    replace #1 (cnt 'r' (map revert (firstn a i))) with (cnt 'u' (firstn a i));
    apply (⁨cnt_of_map ?0 ?2 ?4 {'r', 'u'} ?8 ?10 ?12 ?14 ?16⁩);
    auto_set;
    add_hyp (⁨member_set (firstn a i) ⊆ member_set a);
    apply member_set_firstn;
    apply (⁨included_trans ?0 ?2 (member_set a) ?6 ?8 ?10⁩);
    apply member_set_is_two_element_l;
    lia;
    assumption;
    apply injective_fold;
    intros;
    apply union_unfold in H1;
    apply union_unfold in H2;
    destruct H1 with (or_ind ? ?);
    destruct H2 with (or_ind ? ?);
    auto_set;
    revert H3;
    apply singleton_unfold in H1;
    apply eq_sym in H1;
    apply singleton_unfold in H2;
    apply eq_sym in H2;
    rewrite H1;
    apply eq_sym in H1;
    rewrite H2;
    replace #1 (revert 'u') with ('r');
    rewrite revert_property;
    apply if_false;
    assumption;
    replace #1 (revert 'r') with ('u');
    rewrite revert_property;
    apply if_true;
    auto_list;
    assumption;
    destruct H2 with (or_ind ? ?);
    revert H3;
    apply singleton_unfold in H1;
    apply eq_sym in H1;
    apply singleton_unfold in H2;
    apply eq_sym in H2;
    rewrite H1;
    apply eq_sym in H1;
    rewrite H2;
    replace #1 (revert 'u') with ('r');
    rewrite revert_property;
    apply if_false;
    assumption;
    replace #1 (revert 'r') with ('u');
    rewrite revert_property;
    apply if_true;
    auto_list;
    assumption;
    auto_set;
    replace #1 (cnt 'u' (map revert (firstn a i))) with (cnt 'r' (firstn a i));
    apply (⁨cnt_of_map ?0 ?2 ?4 {'r', 'u'} ?8 ?10 ?12 ?14 ?16⁩);
    auto_set;
    apply (⁨included_trans ?0 ?2 (member_set a) ?6 ?8 ?10⁩);
    apply member_set_is_two_element_l;
    apply eq_sym;
    lia;
    apply member_set_firstn;
    apply injective_fold;
    intros;
    apply union_unfold in H1;
    apply union_unfold in H2;
    destruct H1 with (or_ind ? ?);
    destruct H2 with (or_ind ? ?);
    auto_set;
    revert H3;
    apply singleton_unfold in H1;
    apply eq_sym in H1;
    apply singleton_unfold in H2;
    apply eq_sym in H2;
    rewrite H1;
    apply eq_sym in H1;
    rewrite H2;
    replace #1 (revert 'u') with ('r');
    rewrite revert_property;
    apply if_false;
    assumption;
    replace #1 (revert 'r') with ('u');
    rewrite revert_property;
    apply if_true;
    auto_list;
    assumption;
    destruct H2 with (or_ind ? ?);
    revert H3;
    apply singleton_unfold in H1;
    apply eq_sym in H1;
    apply singleton_unfold in H2;
    apply eq_sym in H2;
    rewrite H1;
    apply eq_sym in H1;
    rewrite H2;
    replace #1 (revert 'u') with ('r');
    rewrite revert_property;
    apply if_false;
    assumption;
    replace #1 (revert 'r') with ('u');
    rewrite revert_property;
    apply if_true;
    auto_list;
    assumption;
    auto_set;
    auto_set;
    Seq (add_hyp (⁨- 1 < j⁩)) (remove_hyp i_property_r_r_ex) (Switch 1) (add_hyp i_property_r_r_ex_o := (i_property_r_r_ex H1)) (remove_hyp H1) (remove_hyp i_property_r_r_ex);
    Seq (add_hyp (⁨j ≤ |a| ∧ cnt 'r' (firstn a j) = cnt 'u' (firstn a j) + 1⁩)) (remove_hyp i_property_r_r_ex_o) (Switch 1) (add_hyp i_property_r_r_ex_o_o := (i_property_r_r_ex_o H1)) (remove_hyp H1) (remove_hyp i_property_r_r_ex_o);
    lia;
    apply and_intro;
    replace #1 ((firstn (map revert (firstn a i) + skipn a i) j)) with (((firstn (map revert (firstn a i)) j))) in j_property_r_r_l;
    apply firstn_append_l;
    replace #1 (| map revert (firstn a i)|) with (|(firstn a i)|);
    apply map_len;
    replace #1 (|firstn a i|) with (i);
    apply len_firstn;
    assumption;
    lia;
    assumption;
    replace #1 ((firstn (map revert (firstn a i) + skipn a i) j)) with (((firstn (map revert (firstn a i) ) j))) in j_property_r_r_l;
    apply firstn_append_l;
    replace #1 (| map revert (firstn a i)|) with (|(firstn a i)|);
    apply map_len;
    replace #1 (|firstn a i|) with (i);
    apply len_firstn;
    assumption;
    lia;
    assumption;
    replace #1 ((firstn (map revert (firstn a i)) j)) with (((map revert (firstn a j)))) in j_property_r_r_l;
    replace #1 (firstn (map revert (firstn a i)) j) with ((map revert (firstn (firstn a i) j) ));
    apply firstn_map;
    replace #1 ((firstn (firstn a i) j)) with ((firstn a j));
    apply firstn_firstn;
    assumption;
    auto_list;
    replace #1 ((firstn (map revert (firstn a i)) j)) with (map revert (firstn a j)) in j_property_r_r_l;
    replace #1 (firstn (map revert (firstn a i)) j) with (map revert (firstn (firstn a i) j) );
    apply firstn_map;
    replace #1 ((firstn (firstn a i) j)) with ((firstn a j));
    apply firstn_firstn;
    assumption;
    auto_list;
    replace #1 (cnt 'r' (map revert (firstn a j))) with (cnt 'u' (firstn a j)) in j_property_r_r_l;
    apply (⁨cnt_of_map ?0 ?2 ?4 {'r', 'u'} ?8 ?10 ?12 ?14 ?16⁩);
    auto_set;
    apply (⁨included_trans ?0 ?2 (member_set a) ?6 ?8 ?10⁩);
    apply member_set_is_two_element_l;
    lia;
    apply member_set_firstn;
    apply injective_fold;
    intros;
    apply union_unfold in H1;
    apply union_unfold in H2;
    destruct H1 with (or_ind ? ?);
    destruct H2 with (or_ind ? ?);
    auto_set;
    revert H3;
    apply singleton_unfold in H1;
    apply eq_sym in H1;
    apply singleton_unfold in H2;
    apply eq_sym in H2;
    rewrite H1;
    apply eq_sym in H1;
    rewrite H2;
    replace #1 (revert 'u') with ('r');
    rewrite revert_property;
    apply if_false;
    assumption;
    replace #1 (revert 'r') with ('u');
    rewrite revert_property;
    apply if_true;
    auto_list;
    assumption;
    destruct H2 with (or_ind ? ?);
    revert H3;
    apply singleton_unfold in H1;
    apply eq_sym in H1;
    apply singleton_unfold in H2;
    apply eq_sym in H2;
    rewrite H1;
    apply eq_sym in H1;
    rewrite H2;
    replace #1 (revert 'u') with ('r');
    rewrite revert_property;
    apply if_false;
    assumption;
    replace #1 (revert 'r') with ('u');
    rewrite revert_property;
    apply if_true;
    auto_list;
    assumption;
    auto_set;
    replace #1 (cnt 'u' (map revert (firstn a j))) with ((cnt 'r' (firstn a j))) in j_property_r_r_l;
    apply (⁨cnt_of_map ?0 ?2 ?4 {'r', 'u'} ?8 ?10 ?12 ?14 ?16⁩);
    auto_set;
    apply (⁨included_trans ?0 ?2 (member_set a) ?6 ?8 ?10⁩);
    apply member_set_is_two_element_l;
    lia;
    apply member_set_firstn;
    apply injective_fold;
    intros;
    apply union_unfold in H1;
    apply union_unfold in H2;
    destruct H1 with (or_ind ? ?);
    destruct H2 with (or_ind ? ?);
    auto_set;
    revert H3;
    apply singleton_unfold in H1;
    apply eq_sym in H1;
    apply singleton_unfold in H2;
    apply eq_sym in H2;
    rewrite H1;
    apply eq_sym in H1;
    rewrite H2;
    replace #1 (revert 'u') with ('r');
    rewrite revert_property;
    apply if_false;
    assumption;
    replace #1 (revert 'r') with ('u');
    rewrite revert_property;
    apply if_true;
    auto_list;
    assumption;
    destruct H2 with (or_ind ? ?);
    revert H3;
    apply singleton_unfold in H1;
    apply eq_sym in H1;
    apply singleton_unfold in H2;
    apply eq_sym in H2;
    rewrite H1;
    apply eq_sym in H1;
    rewrite H2;
    replace #1 (revert 'u') with ('r');
    rewrite revert_property;
    apply if_false;
    assumption;
    replace #1 (revert 'r') with ('u');
    rewrite revert_property;
    apply if_true;
    auto_list;
    assumption;
    auto_set;
    auto_set;
    add_hyp (~ i  =0);
    intros;
    destruct i_property_r_l with (and_ind ? ?) to (i_property_r_l_l i_property_r_l_r);
    replace #2 (firstn a i) with ([]) in i_property_r_l_r;
    lia;
    replace #1 (firstn a i) with ([]) in i_property_r_l_r;
    lia;
    lia;
    lia;
    lia;
    add_hyp (~ i  =0);
    intros;
    replace #1 ((firstn a i)) with ([]) in i_property_r_l;
    apply firstn_le_0;
    assumption;
    replace #1 ((firstn a i)) with ([]) in i_property_r_l;
    apply firstn_le_0;
    assumption;
    lia;
    lia;
    rewrite j_property_r_r_r_r_r;
    rewrite H1;
    replace #1 ((firstn (map revert (firstn a j) + skipn a j) j)) with (map revert (firstn a j));
    replace #3 (j) with (| map revert (firstn a j)|);
    replace #1 (| map revert (firstn a j)|) with (|(firstn a j)|);
    apply map_len;
    apply eq_sym;
    apply len_firstn;
    lia;
    assumption;
    apply firstn_append_l_len;
    apply eq_sym;
    add_hyp (skipn (map revert (firstn a j) + skipn a j) j = skipn a j);
    replace #3 (j) with (| map revert (firstn a j)|);
    replace #1 (| map revert (firstn a j)|) with (|(firstn a j)|);
    apply map_len;
    apply eq_sym;
    apply len_firstn;
    lia;
    assumption;
    apply skipn_append_l_len;
    rewrite H2;
    apply eq_sym in revert_property;
    rewrite revert_property;
    replace #1 (map revert (map revert (firstn a j))) with ((firstn a j));
    replace #1 (map revert (map revert (firstn a j))) with (map (λ x, revert ( revert x) ) (firstn a j));
    apply map_f_o_g;
    apply map_identity;
    intros;
    add_hyp (a0 ∈ {'r', 'u'});
    apply inlist_member_set in H3;
    add_hyp (member_set a ⊆ {'r', 'u'});
    apply member_set_is_two_element_l;
    lia;
    add_hyp (member_set (firstn a j) ⊆ member_set a );
    apply member_set_firstn;
    apply included_unfold in H5;
    apply H5 in H3;
    apply included_unfold in H4;
    apply H4 in H3;
    assumption;
    apply union_unfold in H4;
    destruct H4 with (or_ind ? ?);
    apply singleton_unfold in H4;
    apply eq_sym in H4;
    rewrite H4;
    replace #1 (revert 'u') with ('r');
    apply eq_sym in revert_property;
    rewrite revert_property;
    apply if_false;
    assumption;
    apply eq_sym in revert_property;
    rewrite revert_property;
    apply if_true;
    auto_list;
    apply singleton_unfold in H4;
    apply eq_sym in H4;
    rewrite H4;
    replace #1 ((revert 'r')) with ('u');
    apply eq_sym in revert_property;
    rewrite revert_property;
    apply if_true;
    auto_list;
    apply eq_sym in revert_property;
    rewrite revert_property;
    apply if_false;
    assumption;
    apply eq_sym;
    apply firstn_skipn;
    apply setminus_fold;
    apply and_intro;
    intros;
    apply set_from_func_unfold in H1;
    destruct H1 with (and_ind ? ?) to (H1_l H1_r);
    destruct H1_r with (and_ind ? ?) to (H1_r_l H1_r_r);
    destruct H1_r_r with (and_ind ? ?) to (H1_r_r_l H1_r_r_r);
    add_hyp H1_r_r_r_ex := (H1_r_r_r (i));
    Seq (add_hyp (⁨0 < i⁩)) (remove_hyp H1_r_r_r_ex) (Switch 1) (add_hyp H1_r_r_r_ex_o := (H1_r_r_r_ex H1)) (remove_hyp H1) (remove_hyp H1_r_r_r_ex);
    Seq (add_hyp (⁨i ≤ | map revert (firstn a i) + skipn a i|⁩)) (remove_hyp H1_r_r_r_ex_o) (Switch 1) (add_hyp H1_r_r_r_ex_o_o := (H1_r_r_r_ex_o H1)) (remove_hyp H1) (remove_hyp H1_r_r_r_ex_o);
    replace #1 ((firstn (map revert (firstn a i) + skipn a i) i)) with ((map revert (firstn a i))) in H1_r_r_r_ex_o_o;
    replace #3 (i) with (| map revert (firstn a i)|);
    replace #1 (| map revert (firstn a i)|) with (| (firstn a i)|);
    apply map_len;
    apply eq_sym;
    apply len_firstn;
    assumption;
    lia;
    apply firstn_append_l_len;
    replace #1 ((firstn (map revert (firstn a i) + skipn a i) i)) with (map revert (firstn a i)) in H1_r_r_r_ex_o_o;
    replace #3 (i) with (| map revert (firstn a i)|);
    replace #1 (| map revert (firstn a i)|) with (| (firstn a i)|);
    apply map_len;
    apply eq_sym;
    apply len_firstn;
    assumption;
    lia;
    apply firstn_append_l_len;
    replace #1 (cnt 'u' (map revert (firstn a i))) with (cnt 'r' (firstn a i)) in H1_r_r_r_ex_o_o;
    apply (⁨cnt_of_map ?0 ?2 ?4 {'r', 'u'} ?8 ?10 ?12 ?14 ?16⁩);
    auto_set;
    apply (⁨included_trans ?0 ?2 (member_set a) ?6 ?8 ?10⁩);
    apply member_set_is_two_element_l;
    apply eq_sym;
    lia;
    apply member_set_firstn;
    apply injective_fold;
    intros;
    apply union_unfold in H1;
    apply union_unfold in H2;
    destruct H1 with (or_ind ? ?);
    destruct H2 with (or_ind ? ?);
    auto_set;
    revert H3;
    apply singleton_unfold in H1;
    apply eq_sym in H1;
    apply singleton_unfold in H2;
    apply eq_sym in H2;
    rewrite H1;
    apply eq_sym in H1;
    rewrite H2;
    replace #1 (revert 'u') with ('r');
    rewrite revert_property;
    apply if_false;
    assumption;
    replace #1 (revert 'r') with ('u');
    rewrite revert_property;
    apply if_true;
    auto_list;
    assumption;
    destruct H2 with (or_ind ? ?);
    revert H3;
    apply singleton_unfold in H1;
    apply eq_sym in H1;
    apply singleton_unfold in H2;
    apply eq_sym in H2;
    rewrite H1;
    apply eq_sym in H1;
    rewrite H2;
    replace #1 (revert 'u') with ('r');
    rewrite revert_property;
    apply if_false;
    assumption;
    replace #1 (revert 'r') with ('u');
    rewrite revert_property;
    apply if_true;
    auto_list;
    assumption;
    auto_set;
    replace #1 (cnt 'r' (map revert (firstn a i))) with ((cnt 'u' (firstn a i))) in H1_r_r_r_ex_o_o;
    apply (⁨cnt_of_map ?0 ?2 ?4 {'r', 'u'} ?8 ?10 ?12 ?14 ?16⁩);
    auto_set;
    add_hyp (⁨member_set (firstn a i) ⊆ member_set a);
    apply member_set_firstn;
    apply (⁨included_trans ?0 ?2 (member_set a) ?6 ?8 ?10⁩);
    apply member_set_is_two_element_l;
    lia;
    assumption;
    apply injective_fold;
    intros;
    apply union_unfold in H1;
    apply union_unfold in H2;
    destruct H1 with (or_ind ? ?);
    destruct H2 with (or_ind ? ?);
    auto_set;
    revert H3;
    apply singleton_unfold in H1;
    apply eq_sym in H1;
    apply singleton_unfold in H2;
    apply eq_sym in H2;
    rewrite H1;
    apply eq_sym in H1;
    apply eq_sym in H1;
    rewrite H2;
    replace #1 (revert 'u') with ('r');
    rewrite revert_property;
    apply if_false;
    assumption;
    replace #1 (revert 'r') with ('u');
    rewrite revert_property;
    apply if_true;
    auto_list;
    assumption;
    destruct H2 with (or_ind ? ?);
    revert H3;
    apply singleton_unfold in H1;
    apply eq_sym in H1;
    apply singleton_unfold in H2;
    apply eq_sym in H2;
    rewrite H1;
    apply eq_sym in H1;
    rewrite H2;
    replace #1 (revert 'u') with ('r');
    rewrite revert_property;
    apply if_false;
    assumption;
    replace #1 (revert 'r') with ('u');
    rewrite revert_property;
    apply if_true;
    auto_list;
    assumption;
    revert H3;
    apply singleton_unfold in H1;
    apply eq_sym in H1;
    apply singleton_unfold in H2;
    apply eq_sym in H2;
    rewrite H1;
    apply eq_sym in H1;
    rewrite H2;
    rewrite revert_property;
    auto_list;
    lia;
    lia;
    add_hyp (~ i  =0);
    intros;
    replace #1 ((firstn a i)) with ([]) in i_property_r_l;
    apply firstn_le_0;
    assumption;
    replace #1 ((firstn a i)) with ([]) in i_property_r_l;
    apply firstn_le_0;
    assumption;
    lia;
    lia;
    apply set_from_func_fold;
    apply and_intro;
    apply and_intro;
    apply H0;
    auto_set;
    apply H0;
    auto_set;
    assumption;
    add_hyp (| map revert (firstn a i) + skipn a i| = 2 * n);
    replace #1 (| map revert (firstn a i) + skipn a i|) with (| map revert (firstn a i) |+| skipn a i|);
    lia;
    replace #1 (| map revert (firstn a i)|) with (|(firstn a i)|);
    apply map_len;
    replace #1 (|firstn a i| + |skipn a i|) with (|firstn a i + skipn a i|);
    lia;
    replace #1 (firstn a i + skipn a i) with (a);
    apply eq_sym;
    apply firstn_skipn;
    lia;
    add_hyp (∀ c: char, c ∈ {'r', 'u'} → cnt c (map revert (firstn a i) + skipn a i) = n);
    intros;
    apply union_unfold in H0;
    replace #1 (cnt c (map revert (firstn a i) + skipn a i)) with (cnt c (map revert (firstn a i)) + cnt c ( skipn a i));
    lia;
    destruct H0 with (or_ind ? ?);
    apply singleton_unfold in H0;
    apply eq_sym in H0;
    rewrite H0;
    replace #1 (cnt 'u' (map revert (firstn a i))) with (((cnt 'r' (firstn a i))));
    apply (⁨cnt_of_map ?0 ?2 ?4 {'r', 'u'} ?8 ?10 ?12 ?14 ?16⁩);
    auto_set;
    apply (⁨included_trans ?0 ?2 (member_set a) ?6 ?8 ?10⁩);
    apply member_set_is_two_element_l;
    lia;
    apply member_set_firstn;
    replace #1 (a) with (firstn a i + skipn a i) in H_l;
    apply firstn_skipn;
    replace #1 (a) with ((firstn a i + skipn a i)) in H_r_l;
    apply firstn_skipn;
    apply injective_fold;
    intros;
    apply union_unfold in H1;
    apply union_unfold in H2;
    destruct H1 with (or_ind ? ?);
    destruct H2 with (or_ind ? ?);
    auto_set;
    revert H3;
    apply singleton_unfold in H1;
    apply eq_sym in H1;
    apply singleton_unfold in H2;
    apply eq_sym in H2;
    rewrite H1;
    apply eq_sym in H1;
    rewrite H2;
    replace #1 (revert 'u') with ('r');
    rewrite revert_property;
    apply if_false;
    assumption;
    replace #1 (revert 'r') with ('u');
    rewrite revert_property;
    apply if_true;
    auto_list;
    assumption;
    destruct H2 with (or_ind ? ?);
    revert H3;
    apply singleton_unfold in H1;
    apply eq_sym in H1;
    apply singleton_unfold in H2;
    apply eq_sym in H2;
    rewrite H1;
    apply eq_sym in H1;
    rewrite H2;
    replace #1 (revert 'u') with ('r');
    rewrite revert_property;
    apply if_false;
    assumption;
    replace #1 (revert 'r') with ('u');
    rewrite revert_property;
    apply if_true;
    auto_list;
    assumption;
    auto_set;
    replace #1 (a) with (firstn a i + skipn a i) in H_l;
    apply firstn_skipn;
    replace #1 (a) with (firstn a i + skipn a i) in H_r_l;
    apply firstn_skipn;
    lia;
    apply singleton_unfold in H0;
    apply eq_sym in H0;
    rewrite H0;
    replace #1 (cnt 'r' (map revert (firstn a i))) with (cnt 'u' (firstn a i));
    apply (⁨cnt_of_map ?0 ?2 ?4 {'r', 'u'} ?8 ?10 ?12 ?14 ?16⁩);
    auto_set;
    add_hyp (⁨member_set (firstn a i) ⊆ member_set a);
    apply member_set_firstn;
    apply (⁨included_trans ?0 ?2 (member_set a) ?6 ?8 ?10⁩);
    apply member_set_is_two_element_l;
    lia;
    assumption;
    apply injective_fold;
    intros;
    apply union_unfold in H1;
    apply union_unfold in H2;
    destruct H1 with (or_ind ? ?);
    destruct H2 with (or_ind ? ?);
    auto_set;
    revert H3;
    apply singleton_unfold in H1;
    apply eq_sym in H1;
    apply singleton_unfold in H2;
    apply eq_sym in H2;
    rewrite H1;
    apply eq_sym in H1;
    apply eq_sym in H1;
    rewrite H2;
    replace #1 (revert 'u') with ('r');
    rewrite revert_property;
    apply if_false;
    assumption;
    replace #1 (revert 'r') with ('u');
    rewrite revert_property;
    apply if_true;
    auto_list;
    assumption;
    destruct H2 with (or_ind ? ?);
    revert H3;
    apply singleton_unfold in H1;
    apply eq_sym in H1;
    apply singleton_unfold in H2;
    apply eq_sym in H2;
    rewrite H1;
    apply eq_sym in H1;
    rewrite H2;
    replace #1 (revert 'u') with ('r');
    rewrite revert_property;
    apply if_false;
    assumption;
    replace #1 (revert 'r') with ('u');
    rewrite revert_property;
    apply if_true;
    auto_list;
    assumption;
    revert H3;
    apply singleton_unfold in H1;
    apply eq_sym in H1;
    apply singleton_unfold in H2;
    apply eq_sym in H2;
    rewrite H1;
    apply eq_sym in H1;
    rewrite H2;
    rewrite revert_property;
    auto_list;
    replace #1 (a) with (firstn a i + skipn a i) in H_l;
    apply firstn_skipn;
    lia;
    apply setminus_fold;
    apply and_intro;
    intros;
    apply set_from_func_unfold in H1;
    destruct H1 with (and_ind ? ?) to (H1_l H1_r);
    destruct H1_r with (and_ind ? ?) to (H1_r_l H1_r_r);
    destruct H1_r_r with (and_ind ? ?) to (H1_r_r_l H1_r_r_r);
    add_hyp H1_r_r_r_ex := (H1_r_r_r (i));
    Seq (add_hyp (⁨0 < i⁩)) (remove_hyp H1_r_r_r_ex) (Switch 1) (add_hyp H1_r_r_r_ex_o := (H1_r_r_r_ex H1)) (remove_hyp H1) (remove_hyp H1_r_r_r_ex);
    Seq (add_hyp (⁨i ≤ | map revert (firstn a i) + skipn a i|⁩)) (remove_hyp H1_r_r_r_ex_o) (Switch 1) (add_hyp H1_r_r_r_ex_o_o := (H1_r_r_r_ex_o H1)) (remove_hyp H1) (remove_hyp H1_r_r_r_ex_o);
    replace #1 ((firstn (map revert (firstn a i) + skipn a i) i)) with ((map revert (firstn a i))) in H1_r_r_r_ex_o_o;
    replace #3 (i) with (| map revert (firstn a i)|);
    replace #1 (| map revert (firstn a i)|) with (| (firstn a i)|);
    apply map_len;
    apply eq_sym;
    apply len_firstn;
    assumption;
    lia;
    apply firstn_append_l_len;
    replace #1 ((firstn (map revert (firstn a i) + skipn a i) i)) with (map revert (firstn a i)) in H1_r_r_r_ex_o_o;
    replace #3 (i) with (| map revert (firstn a i)|);
    replace #1 (| map revert (firstn a i)|) with (| (firstn a i)|);
    apply map_len;
    apply eq_sym;
    apply len_firstn;
    assumption;
    lia;
    apply firstn_append_l_len;
    replace #1 (cnt 'u' (map revert (firstn a i))) with (cnt 'r' (firstn a i)) in H1_r_r_r_ex_o_o;
    apply (⁨cnt_of_map ?0 ?2 ?4 {'r', 'u'} ?8 ?10 ?12 ?14 ?16⁩);
    auto_set;
    apply (⁨included_trans ?0 ?2 (member_set a) ?6 ?8 ?10⁩);
    apply member_set_is_two_element_l;
    apply eq_sym;
    lia;
    apply member_set_firstn;
    apply injective_fold;
    intros;
    apply union_unfold in H1;
    apply union_unfold in H2;
    destruct H1 with (or_ind ? ?);
    destruct H2 with (or_ind ? ?);
    auto_set;
    revert H3;
    apply singleton_unfold in H1;
    apply eq_sym in H1;
    apply singleton_unfold in H2;
    apply eq_sym in H2;
    rewrite H1;
    apply eq_sym in H1;
    rewrite H2;
    replace #1 (revert 'u') with ('r');
    rewrite revert_property;
    apply if_false;
    assumption;
    replace #1 (revert 'r') with ('u');
    rewrite revert_property;
    apply if_true;
    auto_list;
    assumption;
    destruct H2 with (or_ind ? ?);
    revert H3;
    apply singleton_unfold in H1;
    apply eq_sym in H1;
    apply singleton_unfold in H2;
    apply eq_sym in H2;
    rewrite H1;
    apply eq_sym in H1;
    rewrite H2;
    replace #1 (revert 'u') with ('r');
    rewrite revert_property;
    apply if_false;
    assumption;
    replace #1 (revert 'r') with ('u');
    rewrite revert_property;
    apply if_true;
    auto_list;
    assumption;
    auto_set;
    replace #1 (cnt 'r' (map revert (firstn a i))) with ((cnt 'u' (firstn a i))) in H1_r_r_r_ex_o_o;
    apply (⁨cnt_of_map ?0 ?2 ?4 {'r', 'u'} ?8 ?10 ?12 ?14 ?16⁩);
    auto_set;
    add_hyp (⁨member_set (firstn a i) ⊆ member_set a);
    apply member_set_firstn;
    apply (⁨included_trans ?0 ?2 (member_set a) ?6 ?8 ?10⁩);
    apply member_set_is_two_element_l;
    lia;
    assumption;
    apply injective_fold;
    intros;
    apply union_unfold in H1;
    apply union_unfold in H2;
    destruct H1 with (or_ind ? ?);
    destruct H2 with (or_ind ? ?);
    auto_set;
    revert H3;
    apply singleton_unfold in H1;
    apply eq_sym in H1;
    apply singleton_unfold in H2;
    apply eq_sym in H2;
    rewrite H1;
    apply eq_sym in H1;
    apply eq_sym in H1;
    rewrite H2;
    replace #1 (revert 'u') with ('r');
    rewrite revert_property;
    apply if_false;
    assumption;
    replace #1 (revert 'r') with ('u');
    rewrite revert_property;
    apply if_true;
    auto_list;
    assumption;
    destruct H2 with (or_ind ? ?);
    revert H3;
    apply singleton_unfold in H1;
    apply eq_sym in H1;
    apply singleton_unfold in H2;
    apply eq_sym in H2;
    rewrite H1;
    apply eq_sym in H1;
    rewrite H2;
    replace #1 (revert 'u') with ('r');
    rewrite revert_property;
    apply if_false;
    assumption;
    replace #1 (revert 'r') with ('u');
    rewrite revert_property;
    apply if_true;
    auto_list;
    assumption;
    revert H3;
    apply singleton_unfold in H1;
    apply eq_sym in H1;
    apply singleton_unfold in H2;
    apply eq_sym in H2;
    rewrite H1;
    apply eq_sym in H1;
    rewrite H2;
    rewrite revert_property;
    auto_list;
    lia;
    lia;
    add_hyp (~ i  =0);
    intros;
    replace #1 ((firstn a i)) with ([]) in i_property_r_l;
    apply firstn_le_0;
    assumption;
    replace #1 ((firstn a i)) with ([]) in i_property_r_l;
    apply firstn_le_0;
    assumption;
    lia;
    lia;
    apply set_from_func_fold;
    apply and_intro;
    apply and_intro;
    apply H0;
    auto_set;
    apply H0;
    auto_set;
    assumption;
    apply included_fold;
    intros;
    apply projection_in_intro_l in H;
    destruct H with (ex_ind ? ?) to (x x_property);
    add_hyp f_property_ex := (f_property (x));
    Seq (add_hyp (⁨x   ∈ { l: list char | |l| = 2 * n ∧ cnt 'r' l = n ∧ cnt 'u' l = n }       ∖ { l: list char | |l| = 2 * n           ∧ cnt 'r' l = n               ∧ cnt 'u' l = n                   ∧ ∀ i: ℤ,                       0 < i                         → i ≤ |l|                             → cnt 'u' (firstn l i) ≤ cnt 'r' (firstn l i) }⁩)) (remove_hyp f_property_ex) (Switch 1) (add_hyp f_property_ex_o := (f_property_ex H)) (remove_hyp H) (remove_hyp f_property_ex);
    Switch 1;
    assumption;
    destruct f_property_ex_o with (ex_ind ? ?) to (i i_property);
    destruct x_property with (and_ind ? ?) to (x_property_l x_property_r);
    apply setminus_unfold in x_property_l;
    destruct x_property_l with (and_ind ? ?) to (x_property_l_l x_property_l_r);
    destruct i_property with (and_ind ? ?) to (i_property_l i_property_r);
    destruct i_property_r with (and_ind ? ?) to (i_property_r_l i_property_r_r);
    destruct i_property_r_r with (and_ind ? ?) to (i_property_r_r_l i_property_r_r_r);
    destruct i_property_r_r_r with (and_ind ? ?) to (i_property_r_r_r_l i_property_r_r_r_r);
    destruct i_property_r_r_r_r with (and_ind ? ?) to (i_property_r_r_r_r_l i_property_r_r_r_r_r);
    apply set_from_func_fold;
    rewrite x_property_r;
    rewrite i_property_r_r_r_r_r;
    apply and_intro;
    apply and_intro;
    replace #1 (|map (λ c: char, if_f (c = 'r') 'u' 'r') (firstn x i) + skipn x i|) with (|map (λ c: char, if_f (c = 'r') 'u' 'r') (firstn x i) | + |skipn x i|);
    lia;
    replace #1 (|map (λ c: char, if_f (c = 'r') 'u' 'r') (firstn x i)|) with (|(firstn x i)|);
    apply map_len;
    replace #1 (|firstn x i| + |skipn x i|) with (|firstn x i + skipn x i|);
    lia;
    replace #1 (firstn x i + skipn x i) with (x);
    apply eq_sym;
    apply firstn_skipn;
    apply set_from_func_unfold in x_property_l_l;
    lia;
    replace #1 (cnt 'u' (map (λ c: char, if_f (c = 'r') 'u' 'r') (firstn x i) + skipn x i)) with (cnt 'u' (map (λ c: char, if_f (c = 'r') 'u' 'r') (firstn x i))  + cnt 'u' (skipn x i));
    lia;
    apply eq_sym in revert_property;
    rewrite revert_property;
    replace #1 (cnt 'u' (map revert (firstn x i))) with (cnt 'r' ( (firstn x i)));
    apply (⁨cnt_of_map ?0 ?2 ?4 {'r', 'u'} ?8 ?10 ?12 ?14 ?16⁩);
    auto_set;
    apply (⁨included_trans ?0 ?2 (member_set x) ?6 ?8 ?10⁩);
    apply member_set_is_two_element_l;
    apply set_from_func_unfold in x_property_l_l;
    lia;
    apply member_set_firstn;
    apply set_from_func_unfold in x_property_l_l;
    apply injective_fold;
    intros;
    apply union_unfold in H;
    destruct H with (or_ind ? ?);
    apply union_unfold in H0;
    destruct H0 with (or_ind ? ?);
    auto_set;
    apply singleton_unfold in H;
    revert H1;
    apply singleton_unfold in H0;
    apply eq_sym in H;
    apply eq_sym in H0;
    rewrite H;
    rewrite H0;
    replace #1 (revert 'u') with ('r');
    apply eq_sym in revert_property;
    rewrite revert_property;
    apply if_false;
    assumption;
    replace #1 (revert 'r') with ('u');
    apply eq_sym in revert_property;
    rewrite revert_property;
    apply if_true;
    auto_list;
    assumption;
    apply union_unfold in H0;
    destruct H0 with (or_ind ? ?);
    apply singleton_unfold in H;
    revert H1;
    apply singleton_unfold in H0;
    apply eq_sym in H;
    apply eq_sym in H0;
    rewrite H;
    rewrite H0;
    replace #1 (revert 'u') with ('r');
    apply eq_sym in revert_property;
    rewrite revert_property;
    apply if_false;
    assumption;
    replace #1 (revert 'r') with ('u');
    apply eq_sym in revert_property;
    rewrite revert_property;
    apply if_true;
    auto_list;
    assumption;
    auto_set;
    apply set_from_func_unfold in x_property_l_l;
    destruct x_property_l_l with (and_ind ? ?) to (x_property_l_l_l x_property_l_l_r);
    destruct x_property_l_l_r with (and_ind ? ?) to (x_property_l_l_r_l x_property_l_l_r_r);
    replace #1 (x) with ((firstn x i) + skipn x i) in x_property_l_l_r_l;
    apply firstn_skipn;
    replace #1 (x) with ((firstn x i) + skipn x i) in x_property_l_l_r_r;
    apply firstn_skipn;
    lia;
    apply set_from_func_unfold in x_property_l_l;
    destruct x_property_l_l with (and_ind ? ?) to (x_property_l_l_l x_property_l_l_r);
    destruct x_property_l_l_r with (and_ind ? ?) to (x_property_l_l_r_l x_property_l_l_r_r);
    apply eq_sym in revert_property;
    rewrite revert_property;
    replace #1 (cnt 'r' (map revert (firstn x i) + skipn x i)) with (cnt 'r' (map revert (firstn x i)) + cnt 'r' ( skipn x i));
    lia;
    replace #1 (cnt 'r' (map revert (firstn x i))) with (cnt 'u' ((firstn x i)));
    apply (⁨cnt_of_map ?0 ?2 ?4 {'r', 'u'} ?8 ?10 ?12 ?14 ?16⁩);
    auto_set;
    apply (⁨included_trans ?0 ?2 (member_set x) ?6 ?8 ?10⁩);
    apply member_set_is_two_element_l;
    lia;
    apply member_set_firstn;
    apply injective_fold;
    intros;
    apply union_unfold in H;
    destruct H with (or_ind ? ?);
    apply union_unfold in H0;
    destruct H0 with (or_ind ? ?);
    auto_set;
    apply singleton_unfold in H;
    revert H1;
    apply singleton_unfold in H0;
    apply eq_sym in H;
    apply eq_sym in H0;
    rewrite H;
    rewrite H0;
    replace #1 (revert 'u') with ('r');
    apply eq_sym in revert_property;
    rewrite revert_property;
    apply if_false;
    assumption;
    replace #1 (revert 'r') with ('u');
    apply eq_sym in revert_property;
    rewrite revert_property;
    apply if_true;
    auto_list;
    assumption;
    apply union_unfold in H0;
    destruct H0 with (or_ind ? ?);
    apply singleton_unfold in H;
    revert H1;
    apply singleton_unfold in H0;
    apply eq_sym in H;
    apply eq_sym in H0;
    rewrite H;
    rewrite H0;
    replace #1 (revert 'u') with ('r');
    apply eq_sym in revert_property;
    rewrite revert_property;
    apply if_false;
    assumption;
    replace #1 (revert 'r') with ('u');
    apply eq_sym in revert_property;
    rewrite revert_property;
    apply if_true;
    auto_list;
    assumption;
    auto_set;
    replace #1 (x) with ((firstn x i) + skipn x i) in x_property_l_l_r_l;
    apply firstn_skipn;
    lia;
    replace #1 (2 * n) with ( n + 1 + (n - 1));
    lia;
    apply count_of_paths;
    lia;
    lia;
    apply cm_not_neg;
    lia;
    lia;
    apply injective_fold;
    intros;
    add_hyp f_property_ex := (f_property (x));
    Seq (add_hyp (⁨x   ∈ { l: list char | |l| = 2 * n ∧ cnt 'r' l = n ∧ cnt 'u' l = n }       ∖ { l: list char | |l| = 2 * n           ∧ cnt 'r' l = n               ∧ cnt 'u' l = n                   ∧ ∀ i: ℤ,                       0 < i                         → i ≤ |l|                             → cnt 'u' (firstn l i) ≤ cnt 'r' (firstn l i) }⁩)) (remove_hyp f_property_ex) (Switch 1) (add_hyp f_property_ex_o := (f_property_ex H2)) (remove_hyp H2) (remove_hyp f_property_ex);
    add_hyp f_property_ex := (f_property (y));
    Seq (add_hyp (⁨y   ∈ { l: list char | |l| = 2 * n ∧ cnt 'r' l = n ∧ cnt 'u' l = n }       ∖ { l: list char | |l| = 2 * n           ∧ cnt 'r' l = n               ∧ cnt 'u' l = n                   ∧ ∀ i: ℤ,                       0 < i                         → i ≤ |l|                             → cnt 'u' (firstn l i) ≤ cnt 'r' (firstn l i) }⁩)) (remove_hyp f_property_ex) (Switch 1) (add_hyp f_property_ex_o0 := (f_property_ex H2)) (remove_hyp H2) (remove_hyp f_property_ex);
    destruct f_property_ex_o with (ex_ind ? ?) to (i i_property);
    destruct f_property_ex_o0 with (ex_ind ? ?) to (j j_property);
    destruct i_property with (and_ind ? ?) to (i_property_l i_property_r);
    destruct i_property_r with (and_ind ? ?) to (i_property_r_l i_property_r_r);
    destruct j_property with (and_ind ? ?) to (j_property_l j_property_r);
    destruct j_property_r with (and_ind ? ?) to (j_property_r_l j_property_r_r);
    destruct i_property_r_r with (and_ind ? ?) to (i_property_r_r_l i_property_r_r_r);
    destruct j_property_r_r with (and_ind ? ?) to (j_property_r_r_l j_property_r_r_r);
    destruct i_property_r_r_r with (and_ind ? ?) to (i_property_r_r_r_l i_property_r_r_r_r);
    destruct j_property_r_r_r with (and_ind ? ?) to (j_property_r_r_r_l j_property_r_r_r_r);
    destruct i_property_r_r_r_r with (and_ind ? ?) to (i_property_r_r_r_r_l i_property_r_r_r_r_r);
    destruct j_property_r_r_r_r with (and_ind ? ?) to (j_property_r_r_r_r_l j_property_r_r_r_r_r);
    add_hyp i_property_r_r_r_r_l_ex := (i_property_r_r_r_r_l (j));
    add_hyp j_property_r_r_r_r_l_ex := (j_property_r_r_r_r_l (i));
    add_hyp (i = j);
    Seq (add_hyp (⁨0 < j⁩)) (remove_hyp i_property_r_r_r_r_l_ex) (Switch 1) (add_hyp i_property_r_r_r_r_l_ex_o := (i_property_r_r_r_r_l_ex H2)) (remove_hyp H2) (remove_hyp i_property_r_r_r_r_l_ex);
    Seq (add_hyp (⁨0 < i⁩)) (remove_hyp j_property_r_r_r_r_l_ex) (Switch 1) (add_hyp j_property_r_r_r_r_l_ex_o := (j_property_r_r_r_r_l_ex H2)) (remove_hyp H2) (remove_hyp j_property_r_r_r_r_l_ex);
    Seq (add_hyp (⁨cnt 'u' (firstn (f x) j) + 1 = cnt 'r' (firstn (f x) j)⁩)) (remove_hyp i_property_r_r_r_r_l_ex_o) (Switch 1) (add_hyp i_property_r_r_r_r_l_ex_o_o := (i_property_r_r_r_r_l_ex_o H2)) (remove_hyp H2) (remove_hyp i_property_r_r_r_r_l_ex_o);
    apply setminus_unfold in H;
    Seq (add_hyp (⁨cnt 'u' (firstn (f y) i) + 1 = cnt 'r' (firstn (f y) i)⁩)) (remove_hyp j_property_r_r_r_r_l_ex_o) (Switch 1) (add_hyp j_property_r_r_r_r_l_ex_o_o := (j_property_r_r_r_r_l_ex_o H2)) (remove_hyp H2) (remove_hyp j_property_r_r_r_r_l_ex_o);
    lia;
    apply eq_sym in H1;
    rewrite H1;
    rewrite i_property_r_r_r_r_r;
    replace #1 ((firstn (map (λ c: char, if_f (c = 'r') 'u' 'r') (firstn x i) + skipn x i) i)) with (map (λ c: char, if_f (c = 'r') 'u' 'r') (firstn x i));
    apply eq_sym in revert_property;
    rewrite revert_property;
    replace #3 (i) with (| map revert (firstn x i)|);
    replace #1 (| map revert (firstn x i)|) with (| (firstn x i)|);
    apply map_len;
    apply eq_sym;
    apply len_firstn;
    assumption;
    lia;
    apply firstn_append_l_len;
    replace #1 ((firstn (map (λ c: char, if_f (c = 'r') 'u' 'r') (firstn x i) + skipn x i) i)) with (map (λ c: char, if_f (c = 'r') 'u' 'r') (firstn x i));
    apply eq_sym in revert_property;
    rewrite revert_property;
    replace #3 (i) with (| map revert (firstn x i)|);
    replace #1 (| map revert (firstn x i)|) with (| (firstn x i)|);
    apply map_len;
    apply eq_sym;
    apply len_firstn;
    assumption;
    lia;
    apply firstn_append_l_len;
    apply eq_sym in revert_property;
    rewrite revert_property;
    replace #1 (cnt 'u' (map revert (firstn x i))) with (cnt 'r' ( (firstn x i)));
    apply (⁨cnt_of_map ?0 ?2 ?4 {'r', 'u'} ?8 ?10 ?12 ?14 ?16⁩);
    auto_set;
    apply (⁨included_trans ?0 ?2 (member_set x) ?6 ?8 ?10⁩);
    apply member_set_is_two_element_l;
    destruct H with (and_ind ? ?) to (H_l H_r);
    apply set_from_func_unfold in H_l;
    lia;
    apply member_set_firstn;
    destruct H with (and_ind ? ?) to (H_l H_r);
    apply set_from_func_unfold in H_l;
    destruct H_l with (and_ind ? ?) to (H_l_l H_l_r);
    apply injective_fold;
    intros;
    apply union_unfold in H;
    apply union_unfold in H2;
    destruct H with (or_ind ? ?);
    destruct H2 with (or_ind ? ?);
    apply singleton_unfold in H;
    auto_set;
    apply singleton_unfold in H;
    apply singleton_unfold in H2;
    apply eq_sym in H;
    apply eq_sym in H2;
    revert H3;
    rewrite H;
    rewrite H2;
    replace #1 (revert 'u') with ('r');
    apply eq_sym in revert_property;
    rewrite revert_property;
    apply if_false;
    assumption;
    replace #1 (revert 'r') with ('u');
    apply eq_sym in revert_property;
    rewrite revert_property;
    apply if_true;
    auto_list;
    assumption;
    destruct H2 with (or_ind ? ?);
    apply singleton_unfold in H;
    apply singleton_unfold in H2;
    apply eq_sym in H;
    apply eq_sym in H2;
    revert H3;
    rewrite H;
    rewrite H2;
    replace #1 (revert 'u') with ('r');
    apply eq_sym in revert_property;
    rewrite revert_property;
    apply if_false;
    assumption;
    replace #1 (revert 'r') with ('u');
    apply eq_sym in revert_property;
    rewrite revert_property;
    apply if_true;
    auto_list;
    assumption;
    auto_set;
    replace #1 (cnt 'r' (map revert (firstn x i))) with (cnt 'u' ((firstn x i)));
    apply (⁨cnt_of_map ?0 ?2 ?4 {'r', 'u'} ?8 ?10 ?12 ?14 ?16⁩);
    auto_set;
    apply (⁨included_trans ?0 ?2 (member_set x) ?6 ?8 ?10⁩);
    apply member_set_is_two_element_l;
    destruct H with (and_ind ? ?) to (H_l H_r);
    apply set_from_func_unfold in H_l;
    lia;
    apply member_set_firstn;
    destruct H with (and_ind ? ?) to (H_l H_r);
    apply set_from_func_unfold in H_l;
    destruct H_l with (and_ind ? ?) to (H_l_l H_l_r);
    apply injective_fold;
    intros;
    apply union_unfold in H;
    apply union_unfold in H2;
    destruct H with (or_ind ? ?);
    destruct H2 with (or_ind ? ?);
    apply singleton_unfold in H;
    auto_set;
    apply singleton_unfold in H;
    apply singleton_unfold in H2;
    apply eq_sym in H;
    apply eq_sym in H2;
    revert H3;
    rewrite H;
    rewrite H2;
    replace #1 (revert 'u') with ('r');
    apply eq_sym in revert_property;
    rewrite revert_property;
    apply if_false;
    assumption;
    replace #1 (revert 'r') with ('u');
    apply eq_sym in revert_property;
    rewrite revert_property;
    apply if_true;
    auto_list;
    assumption;
    destruct H2 with (or_ind ? ?);
    apply singleton_unfold in H;
    apply singleton_unfold in H2;
    apply eq_sym in H;
    apply eq_sym in H2;
    revert H3;
    rewrite H;
    rewrite H2;
    replace #1 (revert 'u') with ('r');
    apply eq_sym in revert_property;
    rewrite revert_property;
    apply if_false;
    assumption;
    replace #1 (revert 'r') with ('u');
    apply eq_sym in revert_property;
    rewrite revert_property;
    apply if_true;
    auto_list;
    assumption;
    auto_set;
    assumption;
    rewrite H1;
    rewrite j_property_r_r_r_r_r;
    replace #1 ((firstn (map (λ c: char, if_f (c = 'r') 'u' 'r') (firstn y j) + skipn y j) j)) with (map (λ c: char, if_f (c = 'r') 'u' 'r') (firstn y j));
    replace #3 (j) with (|map (λ c: char, if_f (c = 'r') 'u' 'r') (firstn y j)|);
    replace #1 (|map (λ c: char, if_f (c = 'r') 'u' 'r') (firstn y j)|) with (| (firstn y j)|);
    apply map_len;
    apply eq_sym;
    apply len_firstn;
    assumption;
    assumption;
    apply firstn_append_l_len;
    replace #1 ((firstn (map (λ c: char, if_f (c = 'r') 'u' 'r') (firstn y j) + skipn y j) j)) with (map (λ c: char, if_f (c = 'r') 'u' 'r') (firstn y j));
    replace #3 (j) with (|map (λ c: char, if_f (c = 'r') 'u' 'r') (firstn y j)|);
    replace #1 (|map (λ c: char, if_f (c = 'r') 'u' 'r') (firstn y j)|) with (| (firstn y j)|);
    apply map_len;
    apply eq_sym;
    apply len_firstn;
    assumption;
    assumption;
    apply firstn_append_l_len;
    apply eq_sym in revert_property;
    rewrite revert_property;
    replace #1 (cnt 'u' (map revert (firstn y j))) with (cnt 'r' ( (firstn y j)));
    apply (⁨cnt_of_map ?0 ?2 ?4 {'r', 'u'} ?8 ?10 ?12 ?14 ?16⁩);
    auto_set;
    apply (⁨included_trans ?0 ?2 (member_set y) ?6 ?8 ?10⁩);
    apply member_set_is_two_element_l;
    apply setminus_unfold in H0;
    destruct H0 with (and_ind ? ?) to (H0_l H0_r);
    apply set_from_func_unfold in H0_l;
    lia;
    apply member_set_firstn;
    apply injective_fold;
    intros;
    apply union_unfold in H2;
    destruct H2 with (or_ind ? ?);
    apply union_unfold in H3;
    destruct H3 with (or_ind ? ?);
    auto_set;
    apply singleton_unfold in H2;
    apply singleton_unfold in H3;
    apply eq_sym in H2;
    apply eq_sym in H3;
    revert H4;
    rewrite H2;
    rewrite H3;
    replace #1 (revert 'u') with ('r');
    apply eq_sym in revert_property;
    rewrite revert_property;
    apply if_false;
    assumption;
    replace #1 (revert 'r') with ('u');
    apply eq_sym in revert_property;
    rewrite revert_property;
    apply if_true;
    auto_list;
    assumption;
    apply union_unfold in H3;
    destruct H3 with (or_ind ? ?);
    apply singleton_unfold in H2;
    apply singleton_unfold in H3;
    apply eq_sym in H2;
    apply eq_sym in H3;
    revert H4;
    rewrite H2;
    rewrite H3;
    replace #1 (revert 'u') with ('r');
    apply eq_sym in revert_property;
    rewrite revert_property;
    apply if_false;
    assumption;
    replace #1 (revert 'r') with ('u');
    apply eq_sym in revert_property;
    rewrite revert_property;
    apply if_true;
    auto_list;
    assumption;
    auto_set;
    replace #1 (cnt 'r' (map revert (firstn y j))) with (cnt 'u' ((firstn y j)));
    apply (⁨cnt_of_map ?0 ?2 ?4 {'r', 'u'} ?8 ?10 ?12 ?14 ?16⁩);
    auto_set;
    apply (⁨included_trans ?0 ?2 (member_set y) ?6 ?8 ?10⁩);
    apply member_set_is_two_element_l;
    apply setminus_unfold in H0;
    destruct H0 with (and_ind ? ?) to (H0_l H0_r);
    apply set_from_func_unfold in H0_l;
    lia;
    apply member_set_firstn;
    apply injective_fold;
    intros;
    apply union_unfold in H2;
    destruct H2 with (or_ind ? ?);
    apply union_unfold in H3;
    destruct H3 with (or_ind ? ?);
    auto_set;
    apply singleton_unfold in H2;
    apply singleton_unfold in H3;
    apply eq_sym in H2;
    apply eq_sym in H3;
    revert H4;
    rewrite H2;
    rewrite H3;
    replace #1 (revert 'u') with ('r');
    apply eq_sym in revert_property;
    rewrite revert_property;
    apply if_false;
    assumption;
    replace #1 (revert 'r') with ('u');
    apply eq_sym in revert_property;
    rewrite revert_property;
    apply if_true;
    auto_list;
    assumption;
    apply union_unfold in H3;
    destruct H3 with (or_ind ? ?);
    apply singleton_unfold in H2;
    apply singleton_unfold in H3;
    apply eq_sym in H2;
    apply eq_sym in H3;
    revert H4;
    rewrite H2;
    rewrite H3;
    replace #1 (revert 'u') with ('r');
    apply eq_sym in revert_property;
    rewrite revert_property;
    apply if_false;
    assumption;
    replace #1 (revert 'r') with ('u');
    apply eq_sym in revert_property;
    rewrite revert_property;
    apply if_true;
    auto_list;
    assumption;
    auto_set;
    assumption;
    assumption;
    assumption;
    revert j_property_r_r_r_r_r;
    apply eq_sym in H1;
    rewrite H1;
    rewrite i_property_r_r_r_r_r;
    apply eq_sym in revert_property;
    rewrite revert_property;
    rewrite H2;
    intros;
    apply append_eq in j_property_r_r_r_r_r;
    replace #1 (| map revert (firstn x j)|) with (|(firstn x j)|);
    apply map_len;
    replace #1 (|firstn x j|) with (j);
    apply len_firstn;
    lia;
    assumption;
    replace #1 (| map revert (firstn y j)|) with (|(firstn y j)|);
    apply map_len;
    apply eq_sym;
    apply len_firstn;
    assumption;
    assumption;
    destruct j_property_r_r_r_r_r with (and_ind ? ?) to (j_property_r_r_r_r_r_l j_property_r_r_r_r_r_r);
    add_hyp (injective (λ l, map revert l) ({ l: list char | member_set l ⊆ {'r', 'u'} }));
    Switch 1;
    apply injective_unfold in H3;
    apply H3 in j_property_r_r_r_r_r_l;
    apply set_from_func_fold;
    apply (⁨included_trans ?0 ?2 (member_set y) ?6 ?8 ?10⁩);
    apply member_set_is_two_element_l;
    apply setminus_unfold in H0;
    destruct H0 with (and_ind ? ?) to (H0_l H0_r);
    apply set_from_func_unfold in H0_l;
    lia;
    apply member_set_firstn;
    apply set_from_func_fold;
    apply eq_sym in H2;
    rewrite H2;
    apply (⁨included_trans ?0 ?2 (member_set x) ?6 ?8 ?10⁩);
    apply member_set_is_two_element_l;
    apply setminus_unfold in H;
    destruct H with (and_ind ? ?) to (H_l H_r);
    apply set_from_func_unfold in H_l;
    lia;
    apply member_set_firstn;
    replace #1 (x) with (firstn x j + skipn x j);
    apply eq_sym in H2;
    rewrite H2;
    apply firstn_skipn;
    replace #1 (y) with (firstn y j + skipn y j);
    apply firstn_skipn;
    rewrite j_property_r_r_r_r_r_l;
    rewrite j_property_r_r_r_r_r_r;
    auto_list;
    apply (⁨injective_map ?0 ?2 ?4 ?6 {'r', 'u'} ?10 ?12⁩);
    apply setminus_unfold in H;
    apply injective_fold;
    intros;
    apply union_unfold in H3;
    destruct H3 with (or_ind ? ?);
    apply union_unfold in H4;
    destruct H4 with (or_ind ? ?);
    auto_set;
    revert H5;
    apply singleton_unfold in H3;
    apply singleton_unfold in H4;
    apply eq_sym in H3;
    apply eq_sym in H4;
    rewrite H3;
    rewrite H4;
    replace #1 (revert 'u') with ('r');
    apply eq_sym in revert_property;
    rewrite revert_property;
    apply if_false;
    assumption;
    replace #1 (revert 'r') with ('u');
    apply eq_sym in revert_property;
    rewrite revert_property;
    apply if_true;
    auto_list;
    assumption;
    apply union_unfold in H4;
    destruct H4 with (or_ind ? ?);
    revert H5;
    apply singleton_unfold in H3;
    apply singleton_unfold in H4;
    apply eq_sym in H3;
    apply eq_sym in H4;
    rewrite H3;
    rewrite H4;
    replace #1 (revert 'u') with ('r');
    apply eq_sym in revert_property;
    rewrite revert_property;
    apply if_false;
    assumption;
    replace #1 (revert 'r') with ('u');
    apply eq_sym in revert_property;
    rewrite revert_property;
    apply if_true;
    auto_list;
    assumption;
    auto_set;
    intros;
    apply set_from_func_unfold in H3;
    assumption;
    assumption;
    assumption;
    replace #2 ((2 * n)) with ((n + n));
    lia;
    replace #1 ({ l: list char | |l| = 2 * n ∧ cnt 'r' l = n ∧ cnt 'u' l = n }) with ({ l: list char | cnt 'r' l = n ∧ cnt 'u' l = n ∧ |l| = 2 * n  });
    apply set_equality;
    apply included_fold;
    intros;
    apply set_from_func_unfold in H;
    apply set_from_func_fold;
    assumption;
    apply included_fold;
    intros;
    apply set_from_func_unfold in H;
    apply set_from_func_fold;
    assumption;
    replace #1 (2 * n) with ( n + n);
    lia;
    apply count_of_paths;
    assumption;
    assumption;
    apply cm_not_neg;
    lia;
    lia;
    apply cm_not_neg;
    assumption;
    lia;
    add_hyp (cm (2 * n) ((n - 1) + 1) > cm (2 * n) (n - 1));
    apply cm_gt;
    lia;
    lia;
    lia;
    apply (⁨injective_map ?0 ?2 ?4 ?6 {'(', ')'} ?10 ?12⁩);
    apply injective_fold;
    intros;
    apply union_unfold in H;
    apply union_unfold in H0;
    destruct H with (or_ind ? ?);
    destruct H0 with (or_ind ? ?);
    auto_set;
    revert H1;
    apply singleton_unfold in H;
    apply singleton_unfold in H0;
    apply eq_sym in H;
    apply eq_sym in H0;
    rewrite H;
    rewrite H0;
    replace #1 (if_f (')' = '(') 'r' 'u') with ('u');
    apply if_false;
    assumption;
    replace #1 (if_f ('(' = '(') 'r' 'u') with ('r');
    apply if_true;
    auto_list;
    assumption;
    destruct H0 with (or_ind ? ?);
    revert H1;
    apply singleton_unfold in H;
    apply singleton_unfold in H0;
    apply eq_sym in H;
    apply eq_sym in H0;
    rewrite H;
    rewrite H0;
    replace #1 (if_f (')' = '(') 'r' 'u') with ('u');
    apply if_false;
    assumption;
    replace #1 (if_f ('(' = '(') 'r' 'u') with ('r');
    apply if_true;
    auto_list;
    assumption;
    auto_set;
    intros;
    apply set_from_func_unfold in H;
    apply member_set_is_two_element_l;
    lia;
Qed
